// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/in-toto/archivista/ent/attestation"
	"github.com/in-toto/archivista/ent/gitattestation"
	"github.com/in-toto/archivista/ent/predicate"
)

// GitAttestationUpdate is the builder for updating GitAttestation entities.
type GitAttestationUpdate struct {
	config
	hooks    []Hook
	mutation *GitAttestationMutation
}

// Where appends a list predicates to the GitAttestationUpdate builder.
func (gau *GitAttestationUpdate) Where(ps ...predicate.GitAttestation) *GitAttestationUpdate {
	gau.mutation.Where(ps...)
	return gau
}

// SetCommitHash sets the "commit_hash" field.
func (gau *GitAttestationUpdate) SetCommitHash(s string) *GitAttestationUpdate {
	gau.mutation.SetCommitHash(s)
	return gau
}

// SetNillableCommitHash sets the "commit_hash" field if the given value is not nil.
func (gau *GitAttestationUpdate) SetNillableCommitHash(s *string) *GitAttestationUpdate {
	if s != nil {
		gau.SetCommitHash(*s)
	}
	return gau
}

// SetAuthor sets the "author" field.
func (gau *GitAttestationUpdate) SetAuthor(s string) *GitAttestationUpdate {
	gau.mutation.SetAuthor(s)
	return gau
}

// SetNillableAuthor sets the "author" field if the given value is not nil.
func (gau *GitAttestationUpdate) SetNillableAuthor(s *string) *GitAttestationUpdate {
	if s != nil {
		gau.SetAuthor(*s)
	}
	return gau
}

// SetAuthorEmail sets the "author_email" field.
func (gau *GitAttestationUpdate) SetAuthorEmail(s string) *GitAttestationUpdate {
	gau.mutation.SetAuthorEmail(s)
	return gau
}

// SetNillableAuthorEmail sets the "author_email" field if the given value is not nil.
func (gau *GitAttestationUpdate) SetNillableAuthorEmail(s *string) *GitAttestationUpdate {
	if s != nil {
		gau.SetAuthorEmail(*s)
	}
	return gau
}

// SetCommitterName sets the "committer_name" field.
func (gau *GitAttestationUpdate) SetCommitterName(s string) *GitAttestationUpdate {
	gau.mutation.SetCommitterName(s)
	return gau
}

// SetNillableCommitterName sets the "committer_name" field if the given value is not nil.
func (gau *GitAttestationUpdate) SetNillableCommitterName(s *string) *GitAttestationUpdate {
	if s != nil {
		gau.SetCommitterName(*s)
	}
	return gau
}

// SetCommitterEmail sets the "committer_email" field.
func (gau *GitAttestationUpdate) SetCommitterEmail(s string) *GitAttestationUpdate {
	gau.mutation.SetCommitterEmail(s)
	return gau
}

// SetNillableCommitterEmail sets the "committer_email" field if the given value is not nil.
func (gau *GitAttestationUpdate) SetNillableCommitterEmail(s *string) *GitAttestationUpdate {
	if s != nil {
		gau.SetCommitterEmail(*s)
	}
	return gau
}

// SetCommitDate sets the "commit_date" field.
func (gau *GitAttestationUpdate) SetCommitDate(s string) *GitAttestationUpdate {
	gau.mutation.SetCommitDate(s)
	return gau
}

// SetNillableCommitDate sets the "commit_date" field if the given value is not nil.
func (gau *GitAttestationUpdate) SetNillableCommitDate(s *string) *GitAttestationUpdate {
	if s != nil {
		gau.SetCommitDate(*s)
	}
	return gau
}

// SetCommitMessage sets the "commit_message" field.
func (gau *GitAttestationUpdate) SetCommitMessage(s string) *GitAttestationUpdate {
	gau.mutation.SetCommitMessage(s)
	return gau
}

// SetNillableCommitMessage sets the "commit_message" field if the given value is not nil.
func (gau *GitAttestationUpdate) SetNillableCommitMessage(s *string) *GitAttestationUpdate {
	if s != nil {
		gau.SetCommitMessage(*s)
	}
	return gau
}

// SetStatus sets the "status" field.
func (gau *GitAttestationUpdate) SetStatus(s []string) *GitAttestationUpdate {
	gau.mutation.SetStatus(s)
	return gau
}

// AppendStatus appends s to the "status" field.
func (gau *GitAttestationUpdate) AppendStatus(s []string) *GitAttestationUpdate {
	gau.mutation.AppendStatus(s)
	return gau
}

// SetCommitType sets the "commit_type" field.
func (gau *GitAttestationUpdate) SetCommitType(s string) *GitAttestationUpdate {
	gau.mutation.SetCommitType(s)
	return gau
}

// SetNillableCommitType sets the "commit_type" field if the given value is not nil.
func (gau *GitAttestationUpdate) SetNillableCommitType(s *string) *GitAttestationUpdate {
	if s != nil {
		gau.SetCommitType(*s)
	}
	return gau
}

// SetCommitDigest sets the "commit_digest" field.
func (gau *GitAttestationUpdate) SetCommitDigest(s string) *GitAttestationUpdate {
	gau.mutation.SetCommitDigest(s)
	return gau
}

// SetNillableCommitDigest sets the "commit_digest" field if the given value is not nil.
func (gau *GitAttestationUpdate) SetNillableCommitDigest(s *string) *GitAttestationUpdate {
	if s != nil {
		gau.SetCommitDigest(*s)
	}
	return gau
}

// SetSignature sets the "signature" field.
func (gau *GitAttestationUpdate) SetSignature(s string) *GitAttestationUpdate {
	gau.mutation.SetSignature(s)
	return gau
}

// SetNillableSignature sets the "signature" field if the given value is not nil.
func (gau *GitAttestationUpdate) SetNillableSignature(s *string) *GitAttestationUpdate {
	if s != nil {
		gau.SetSignature(*s)
	}
	return gau
}

// SetParentHashes sets the "parent_hashes" field.
func (gau *GitAttestationUpdate) SetParentHashes(s []string) *GitAttestationUpdate {
	gau.mutation.SetParentHashes(s)
	return gau
}

// AppendParentHashes appends s to the "parent_hashes" field.
func (gau *GitAttestationUpdate) AppendParentHashes(s []string) *GitAttestationUpdate {
	gau.mutation.AppendParentHashes(s)
	return gau
}

// SetTreeHash sets the "tree_hash" field.
func (gau *GitAttestationUpdate) SetTreeHash(s string) *GitAttestationUpdate {
	gau.mutation.SetTreeHash(s)
	return gau
}

// SetNillableTreeHash sets the "tree_hash" field if the given value is not nil.
func (gau *GitAttestationUpdate) SetNillableTreeHash(s *string) *GitAttestationUpdate {
	if s != nil {
		gau.SetTreeHash(*s)
	}
	return gau
}

// SetRefs sets the "refs" field.
func (gau *GitAttestationUpdate) SetRefs(s []string) *GitAttestationUpdate {
	gau.mutation.SetRefs(s)
	return gau
}

// AppendRefs appends s to the "refs" field.
func (gau *GitAttestationUpdate) AppendRefs(s []string) *GitAttestationUpdate {
	gau.mutation.AppendRefs(s)
	return gau
}

// SetRemotes sets the "remotes" field.
func (gau *GitAttestationUpdate) SetRemotes(s []string) *GitAttestationUpdate {
	gau.mutation.SetRemotes(s)
	return gau
}

// AppendRemotes appends s to the "remotes" field.
func (gau *GitAttestationUpdate) AppendRemotes(s []string) *GitAttestationUpdate {
	gau.mutation.AppendRemotes(s)
	return gau
}

// SetAttestationID sets the "attestation" edge to the Attestation entity by ID.
func (gau *GitAttestationUpdate) SetAttestationID(id uuid.UUID) *GitAttestationUpdate {
	gau.mutation.SetAttestationID(id)
	return gau
}

// SetAttestation sets the "attestation" edge to the Attestation entity.
func (gau *GitAttestationUpdate) SetAttestation(a *Attestation) *GitAttestationUpdate {
	return gau.SetAttestationID(a.ID)
}

// Mutation returns the GitAttestationMutation object of the builder.
func (gau *GitAttestationUpdate) Mutation() *GitAttestationMutation {
	return gau.mutation
}

// ClearAttestation clears the "attestation" edge to the Attestation entity.
func (gau *GitAttestationUpdate) ClearAttestation() *GitAttestationUpdate {
	gau.mutation.ClearAttestation()
	return gau
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (gau *GitAttestationUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, gau.sqlSave, gau.mutation, gau.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (gau *GitAttestationUpdate) SaveX(ctx context.Context) int {
	affected, err := gau.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (gau *GitAttestationUpdate) Exec(ctx context.Context) error {
	_, err := gau.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (gau *GitAttestationUpdate) ExecX(ctx context.Context) {
	if err := gau.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (gau *GitAttestationUpdate) check() error {
	if _, ok := gau.mutation.AttestationID(); gau.mutation.AttestationCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "GitAttestation.attestation"`)
	}
	return nil
}

func (gau *GitAttestationUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := gau.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(gitattestation.Table, gitattestation.Columns, sqlgraph.NewFieldSpec(gitattestation.FieldID, field.TypeUUID))
	if ps := gau.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := gau.mutation.CommitHash(); ok {
		_spec.SetField(gitattestation.FieldCommitHash, field.TypeString, value)
	}
	if value, ok := gau.mutation.Author(); ok {
		_spec.SetField(gitattestation.FieldAuthor, field.TypeString, value)
	}
	if value, ok := gau.mutation.AuthorEmail(); ok {
		_spec.SetField(gitattestation.FieldAuthorEmail, field.TypeString, value)
	}
	if value, ok := gau.mutation.CommitterName(); ok {
		_spec.SetField(gitattestation.FieldCommitterName, field.TypeString, value)
	}
	if value, ok := gau.mutation.CommitterEmail(); ok {
		_spec.SetField(gitattestation.FieldCommitterEmail, field.TypeString, value)
	}
	if value, ok := gau.mutation.CommitDate(); ok {
		_spec.SetField(gitattestation.FieldCommitDate, field.TypeString, value)
	}
	if value, ok := gau.mutation.CommitMessage(); ok {
		_spec.SetField(gitattestation.FieldCommitMessage, field.TypeString, value)
	}
	if value, ok := gau.mutation.Status(); ok {
		_spec.SetField(gitattestation.FieldStatus, field.TypeJSON, value)
	}
	if value, ok := gau.mutation.AppendedStatus(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, gitattestation.FieldStatus, value)
		})
	}
	if value, ok := gau.mutation.CommitType(); ok {
		_spec.SetField(gitattestation.FieldCommitType, field.TypeString, value)
	}
	if value, ok := gau.mutation.CommitDigest(); ok {
		_spec.SetField(gitattestation.FieldCommitDigest, field.TypeString, value)
	}
	if value, ok := gau.mutation.Signature(); ok {
		_spec.SetField(gitattestation.FieldSignature, field.TypeString, value)
	}
	if value, ok := gau.mutation.ParentHashes(); ok {
		_spec.SetField(gitattestation.FieldParentHashes, field.TypeJSON, value)
	}
	if value, ok := gau.mutation.AppendedParentHashes(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, gitattestation.FieldParentHashes, value)
		})
	}
	if value, ok := gau.mutation.TreeHash(); ok {
		_spec.SetField(gitattestation.FieldTreeHash, field.TypeString, value)
	}
	if value, ok := gau.mutation.Refs(); ok {
		_spec.SetField(gitattestation.FieldRefs, field.TypeJSON, value)
	}
	if value, ok := gau.mutation.AppendedRefs(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, gitattestation.FieldRefs, value)
		})
	}
	if value, ok := gau.mutation.Remotes(); ok {
		_spec.SetField(gitattestation.FieldRemotes, field.TypeJSON, value)
	}
	if value, ok := gau.mutation.AppendedRemotes(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, gitattestation.FieldRemotes, value)
		})
	}
	if gau.mutation.AttestationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   gitattestation.AttestationTable,
			Columns: []string{gitattestation.AttestationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(attestation.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := gau.mutation.AttestationIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   gitattestation.AttestationTable,
			Columns: []string{gitattestation.AttestationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(attestation.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, gau.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{gitattestation.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	gau.mutation.done = true
	return n, nil
}

// GitAttestationUpdateOne is the builder for updating a single GitAttestation entity.
type GitAttestationUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *GitAttestationMutation
}

// SetCommitHash sets the "commit_hash" field.
func (gauo *GitAttestationUpdateOne) SetCommitHash(s string) *GitAttestationUpdateOne {
	gauo.mutation.SetCommitHash(s)
	return gauo
}

// SetNillableCommitHash sets the "commit_hash" field if the given value is not nil.
func (gauo *GitAttestationUpdateOne) SetNillableCommitHash(s *string) *GitAttestationUpdateOne {
	if s != nil {
		gauo.SetCommitHash(*s)
	}
	return gauo
}

// SetAuthor sets the "author" field.
func (gauo *GitAttestationUpdateOne) SetAuthor(s string) *GitAttestationUpdateOne {
	gauo.mutation.SetAuthor(s)
	return gauo
}

// SetNillableAuthor sets the "author" field if the given value is not nil.
func (gauo *GitAttestationUpdateOne) SetNillableAuthor(s *string) *GitAttestationUpdateOne {
	if s != nil {
		gauo.SetAuthor(*s)
	}
	return gauo
}

// SetAuthorEmail sets the "author_email" field.
func (gauo *GitAttestationUpdateOne) SetAuthorEmail(s string) *GitAttestationUpdateOne {
	gauo.mutation.SetAuthorEmail(s)
	return gauo
}

// SetNillableAuthorEmail sets the "author_email" field if the given value is not nil.
func (gauo *GitAttestationUpdateOne) SetNillableAuthorEmail(s *string) *GitAttestationUpdateOne {
	if s != nil {
		gauo.SetAuthorEmail(*s)
	}
	return gauo
}

// SetCommitterName sets the "committer_name" field.
func (gauo *GitAttestationUpdateOne) SetCommitterName(s string) *GitAttestationUpdateOne {
	gauo.mutation.SetCommitterName(s)
	return gauo
}

// SetNillableCommitterName sets the "committer_name" field if the given value is not nil.
func (gauo *GitAttestationUpdateOne) SetNillableCommitterName(s *string) *GitAttestationUpdateOne {
	if s != nil {
		gauo.SetCommitterName(*s)
	}
	return gauo
}

// SetCommitterEmail sets the "committer_email" field.
func (gauo *GitAttestationUpdateOne) SetCommitterEmail(s string) *GitAttestationUpdateOne {
	gauo.mutation.SetCommitterEmail(s)
	return gauo
}

// SetNillableCommitterEmail sets the "committer_email" field if the given value is not nil.
func (gauo *GitAttestationUpdateOne) SetNillableCommitterEmail(s *string) *GitAttestationUpdateOne {
	if s != nil {
		gauo.SetCommitterEmail(*s)
	}
	return gauo
}

// SetCommitDate sets the "commit_date" field.
func (gauo *GitAttestationUpdateOne) SetCommitDate(s string) *GitAttestationUpdateOne {
	gauo.mutation.SetCommitDate(s)
	return gauo
}

// SetNillableCommitDate sets the "commit_date" field if the given value is not nil.
func (gauo *GitAttestationUpdateOne) SetNillableCommitDate(s *string) *GitAttestationUpdateOne {
	if s != nil {
		gauo.SetCommitDate(*s)
	}
	return gauo
}

// SetCommitMessage sets the "commit_message" field.
func (gauo *GitAttestationUpdateOne) SetCommitMessage(s string) *GitAttestationUpdateOne {
	gauo.mutation.SetCommitMessage(s)
	return gauo
}

// SetNillableCommitMessage sets the "commit_message" field if the given value is not nil.
func (gauo *GitAttestationUpdateOne) SetNillableCommitMessage(s *string) *GitAttestationUpdateOne {
	if s != nil {
		gauo.SetCommitMessage(*s)
	}
	return gauo
}

// SetStatus sets the "status" field.
func (gauo *GitAttestationUpdateOne) SetStatus(s []string) *GitAttestationUpdateOne {
	gauo.mutation.SetStatus(s)
	return gauo
}

// AppendStatus appends s to the "status" field.
func (gauo *GitAttestationUpdateOne) AppendStatus(s []string) *GitAttestationUpdateOne {
	gauo.mutation.AppendStatus(s)
	return gauo
}

// SetCommitType sets the "commit_type" field.
func (gauo *GitAttestationUpdateOne) SetCommitType(s string) *GitAttestationUpdateOne {
	gauo.mutation.SetCommitType(s)
	return gauo
}

// SetNillableCommitType sets the "commit_type" field if the given value is not nil.
func (gauo *GitAttestationUpdateOne) SetNillableCommitType(s *string) *GitAttestationUpdateOne {
	if s != nil {
		gauo.SetCommitType(*s)
	}
	return gauo
}

// SetCommitDigest sets the "commit_digest" field.
func (gauo *GitAttestationUpdateOne) SetCommitDigest(s string) *GitAttestationUpdateOne {
	gauo.mutation.SetCommitDigest(s)
	return gauo
}

// SetNillableCommitDigest sets the "commit_digest" field if the given value is not nil.
func (gauo *GitAttestationUpdateOne) SetNillableCommitDigest(s *string) *GitAttestationUpdateOne {
	if s != nil {
		gauo.SetCommitDigest(*s)
	}
	return gauo
}

// SetSignature sets the "signature" field.
func (gauo *GitAttestationUpdateOne) SetSignature(s string) *GitAttestationUpdateOne {
	gauo.mutation.SetSignature(s)
	return gauo
}

// SetNillableSignature sets the "signature" field if the given value is not nil.
func (gauo *GitAttestationUpdateOne) SetNillableSignature(s *string) *GitAttestationUpdateOne {
	if s != nil {
		gauo.SetSignature(*s)
	}
	return gauo
}

// SetParentHashes sets the "parent_hashes" field.
func (gauo *GitAttestationUpdateOne) SetParentHashes(s []string) *GitAttestationUpdateOne {
	gauo.mutation.SetParentHashes(s)
	return gauo
}

// AppendParentHashes appends s to the "parent_hashes" field.
func (gauo *GitAttestationUpdateOne) AppendParentHashes(s []string) *GitAttestationUpdateOne {
	gauo.mutation.AppendParentHashes(s)
	return gauo
}

// SetTreeHash sets the "tree_hash" field.
func (gauo *GitAttestationUpdateOne) SetTreeHash(s string) *GitAttestationUpdateOne {
	gauo.mutation.SetTreeHash(s)
	return gauo
}

// SetNillableTreeHash sets the "tree_hash" field if the given value is not nil.
func (gauo *GitAttestationUpdateOne) SetNillableTreeHash(s *string) *GitAttestationUpdateOne {
	if s != nil {
		gauo.SetTreeHash(*s)
	}
	return gauo
}

// SetRefs sets the "refs" field.
func (gauo *GitAttestationUpdateOne) SetRefs(s []string) *GitAttestationUpdateOne {
	gauo.mutation.SetRefs(s)
	return gauo
}

// AppendRefs appends s to the "refs" field.
func (gauo *GitAttestationUpdateOne) AppendRefs(s []string) *GitAttestationUpdateOne {
	gauo.mutation.AppendRefs(s)
	return gauo
}

// SetRemotes sets the "remotes" field.
func (gauo *GitAttestationUpdateOne) SetRemotes(s []string) *GitAttestationUpdateOne {
	gauo.mutation.SetRemotes(s)
	return gauo
}

// AppendRemotes appends s to the "remotes" field.
func (gauo *GitAttestationUpdateOne) AppendRemotes(s []string) *GitAttestationUpdateOne {
	gauo.mutation.AppendRemotes(s)
	return gauo
}

// SetAttestationID sets the "attestation" edge to the Attestation entity by ID.
func (gauo *GitAttestationUpdateOne) SetAttestationID(id uuid.UUID) *GitAttestationUpdateOne {
	gauo.mutation.SetAttestationID(id)
	return gauo
}

// SetAttestation sets the "attestation" edge to the Attestation entity.
func (gauo *GitAttestationUpdateOne) SetAttestation(a *Attestation) *GitAttestationUpdateOne {
	return gauo.SetAttestationID(a.ID)
}

// Mutation returns the GitAttestationMutation object of the builder.
func (gauo *GitAttestationUpdateOne) Mutation() *GitAttestationMutation {
	return gauo.mutation
}

// ClearAttestation clears the "attestation" edge to the Attestation entity.
func (gauo *GitAttestationUpdateOne) ClearAttestation() *GitAttestationUpdateOne {
	gauo.mutation.ClearAttestation()
	return gauo
}

// Where appends a list predicates to the GitAttestationUpdate builder.
func (gauo *GitAttestationUpdateOne) Where(ps ...predicate.GitAttestation) *GitAttestationUpdateOne {
	gauo.mutation.Where(ps...)
	return gauo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (gauo *GitAttestationUpdateOne) Select(field string, fields ...string) *GitAttestationUpdateOne {
	gauo.fields = append([]string{field}, fields...)
	return gauo
}

// Save executes the query and returns the updated GitAttestation entity.
func (gauo *GitAttestationUpdateOne) Save(ctx context.Context) (*GitAttestation, error) {
	return withHooks(ctx, gauo.sqlSave, gauo.mutation, gauo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (gauo *GitAttestationUpdateOne) SaveX(ctx context.Context) *GitAttestation {
	node, err := gauo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (gauo *GitAttestationUpdateOne) Exec(ctx context.Context) error {
	_, err := gauo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (gauo *GitAttestationUpdateOne) ExecX(ctx context.Context) {
	if err := gauo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (gauo *GitAttestationUpdateOne) check() error {
	if _, ok := gauo.mutation.AttestationID(); gauo.mutation.AttestationCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "GitAttestation.attestation"`)
	}
	return nil
}

func (gauo *GitAttestationUpdateOne) sqlSave(ctx context.Context) (_node *GitAttestation, err error) {
	if err := gauo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(gitattestation.Table, gitattestation.Columns, sqlgraph.NewFieldSpec(gitattestation.FieldID, field.TypeUUID))
	id, ok := gauo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "GitAttestation.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := gauo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, gitattestation.FieldID)
		for _, f := range fields {
			if !gitattestation.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != gitattestation.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := gauo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := gauo.mutation.CommitHash(); ok {
		_spec.SetField(gitattestation.FieldCommitHash, field.TypeString, value)
	}
	if value, ok := gauo.mutation.Author(); ok {
		_spec.SetField(gitattestation.FieldAuthor, field.TypeString, value)
	}
	if value, ok := gauo.mutation.AuthorEmail(); ok {
		_spec.SetField(gitattestation.FieldAuthorEmail, field.TypeString, value)
	}
	if value, ok := gauo.mutation.CommitterName(); ok {
		_spec.SetField(gitattestation.FieldCommitterName, field.TypeString, value)
	}
	if value, ok := gauo.mutation.CommitterEmail(); ok {
		_spec.SetField(gitattestation.FieldCommitterEmail, field.TypeString, value)
	}
	if value, ok := gauo.mutation.CommitDate(); ok {
		_spec.SetField(gitattestation.FieldCommitDate, field.TypeString, value)
	}
	if value, ok := gauo.mutation.CommitMessage(); ok {
		_spec.SetField(gitattestation.FieldCommitMessage, field.TypeString, value)
	}
	if value, ok := gauo.mutation.Status(); ok {
		_spec.SetField(gitattestation.FieldStatus, field.TypeJSON, value)
	}
	if value, ok := gauo.mutation.AppendedStatus(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, gitattestation.FieldStatus, value)
		})
	}
	if value, ok := gauo.mutation.CommitType(); ok {
		_spec.SetField(gitattestation.FieldCommitType, field.TypeString, value)
	}
	if value, ok := gauo.mutation.CommitDigest(); ok {
		_spec.SetField(gitattestation.FieldCommitDigest, field.TypeString, value)
	}
	if value, ok := gauo.mutation.Signature(); ok {
		_spec.SetField(gitattestation.FieldSignature, field.TypeString, value)
	}
	if value, ok := gauo.mutation.ParentHashes(); ok {
		_spec.SetField(gitattestation.FieldParentHashes, field.TypeJSON, value)
	}
	if value, ok := gauo.mutation.AppendedParentHashes(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, gitattestation.FieldParentHashes, value)
		})
	}
	if value, ok := gauo.mutation.TreeHash(); ok {
		_spec.SetField(gitattestation.FieldTreeHash, field.TypeString, value)
	}
	if value, ok := gauo.mutation.Refs(); ok {
		_spec.SetField(gitattestation.FieldRefs, field.TypeJSON, value)
	}
	if value, ok := gauo.mutation.AppendedRefs(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, gitattestation.FieldRefs, value)
		})
	}
	if value, ok := gauo.mutation.Remotes(); ok {
		_spec.SetField(gitattestation.FieldRemotes, field.TypeJSON, value)
	}
	if value, ok := gauo.mutation.AppendedRemotes(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, gitattestation.FieldRemotes, value)
		})
	}
	if gauo.mutation.AttestationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   gitattestation.AttestationTable,
			Columns: []string{gitattestation.AttestationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(attestation.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := gauo.mutation.AttestationIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   gitattestation.AttestationTable,
			Columns: []string{gitattestation.AttestationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(attestation.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &GitAttestation{config: gauo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, gauo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{gitattestation.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	gauo.mutation.done = true
	return _node, nil
}
