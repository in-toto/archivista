// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
)

func (a *Attestation) AttestationCollection(ctx context.Context) (*AttestationCollection, error) {
	result, err := a.Edges.AttestationCollectionOrErr()
	if IsNotLoaded(err) {
		result, err = a.QueryAttestationCollection().Only(ctx)
	}
	return result, err
}

func (ac *AttestationCollection) Attestations(ctx context.Context) ([]*Attestation, error) {
	result, err := ac.Edges.AttestationsOrErr()
	if IsNotLoaded(err) {
		result, err = ac.QueryAttestations().All(ctx)
	}
	return result, err
}

func (ac *AttestationCollection) Statement(ctx context.Context) (*Statement, error) {
	result, err := ac.Edges.StatementOrErr()
	if IsNotLoaded(err) {
		result, err = ac.QueryStatement().Only(ctx)
	}
	return result, err
}

func (d *Dsse) Statement(ctx context.Context) (*Statement, error) {
	result, err := d.Edges.StatementOrErr()
	if IsNotLoaded(err) {
		result, err = d.QueryStatement().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (d *Dsse) Signatures(ctx context.Context) ([]*Signature, error) {
	result, err := d.Edges.SignaturesOrErr()
	if IsNotLoaded(err) {
		result, err = d.QuerySignatures().All(ctx)
	}
	return result, err
}

func (d *Dsse) PayloadDigests(ctx context.Context) ([]*PayloadDigest, error) {
	result, err := d.Edges.PayloadDigestsOrErr()
	if IsNotLoaded(err) {
		result, err = d.QueryPayloadDigests().All(ctx)
	}
	return result, err
}

func (pd *PayloadDigest) Dsse(ctx context.Context) (*Dsse, error) {
	result, err := pd.Edges.DsseOrErr()
	if IsNotLoaded(err) {
		result, err = pd.QueryDsse().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (s *Signature) Dsse(ctx context.Context) (*Dsse, error) {
	result, err := s.Edges.DsseOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryDsse().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (s *Statement) Subjects(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, where *SubjectWhereInput,
) (*SubjectConnection, error) {
	opts := []SubjectPaginateOption{
		WithSubjectFilter(where.Filter),
	}
	totalCount := s.Edges.totalCount[0]
	if nodes, err := s.Edges.SubjectsOrErr(); err == nil || totalCount != nil {
		conn := &SubjectConnection{Edges: []*SubjectEdge{}}
		if totalCount != nil {
			conn.TotalCount = *totalCount
		}
		pager, err := newSubjectPager(opts)
		if err != nil {
			return nil, err
		}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	query := s.QuerySubjects()
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubjectPager(opts)
	if err != nil {
		return nil, err
	}
	if query, err = pager.applyFilter(query); err != nil {
		return nil, err
	}
	conn := &SubjectConnection{Edges: []*SubjectEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
			if totalCount != nil {
				conn.TotalCount = *totalCount
			} else if conn.TotalCount, err = query.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := query.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	query = pager.applyCursors(query, after, before)
	query = pager.applyOrder(query, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		query.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := query.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := query.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

func (s *Statement) AttestationCollections(ctx context.Context) (*AttestationCollection, error) {
	result, err := s.Edges.AttestationCollectionsOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryAttestationCollections().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (s *Statement) Dsse(ctx context.Context) ([]*Dsse, error) {
	result, err := s.Edges.DsseOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryDsse().All(ctx)
	}
	return result, err
}

func (s *Subject) SubjectDigests(ctx context.Context) ([]*SubjectDigest, error) {
	result, err := s.Edges.SubjectDigestsOrErr()
	if IsNotLoaded(err) {
		result, err = s.QuerySubjectDigests().All(ctx)
	}
	return result, err
}

func (s *Subject) Statement(ctx context.Context) (*Statement, error) {
	result, err := s.Edges.StatementOrErr()
	if IsNotLoaded(err) {
		result, err = s.QueryStatement().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (sd *SubjectDigest) Subject(ctx context.Context) (*Subject, error) {
	result, err := sd.Edges.SubjectOrErr()
	if IsNotLoaded(err) {
		result, err = sd.QuerySubject().Only(ctx)
	}
	return result, MaskNotFound(err)
}
