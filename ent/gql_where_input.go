// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/in-toto/archivista/ent/attestation"
	"github.com/in-toto/archivista/ent/attestationcollection"
	"github.com/in-toto/archivista/ent/attestationpolicy"
	"github.com/in-toto/archivista/ent/dsse"
	"github.com/in-toto/archivista/ent/mapping"
	"github.com/in-toto/archivista/ent/omnitrail"
	"github.com/in-toto/archivista/ent/payloaddigest"
	"github.com/in-toto/archivista/ent/posix"
	"github.com/in-toto/archivista/ent/predicate"
	"github.com/in-toto/archivista/ent/signature"
	"github.com/in-toto/archivista/ent/statement"
	"github.com/in-toto/archivista/ent/subject"
	"github.com/in-toto/archivista/ent/subjectdigest"
	"github.com/in-toto/archivista/ent/timestamp"
)

// AttestationWhereInput represents a where input for filtering Attestation queries.
type AttestationWhereInput struct {
	Predicates []predicate.Attestation  `json:"-"`
	Not        *AttestationWhereInput   `json:"not,omitempty"`
	Or         []*AttestationWhereInput `json:"or,omitempty"`
	And        []*AttestationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "omnitrail" edge predicates.
	HasOmnitrail     *bool                  `json:"hasOmnitrail,omitempty"`
	HasOmnitrailWith []*OmnitrailWhereInput `json:"hasOmnitrailWith,omitempty"`

	// "attestation_collection" edge predicates.
	HasAttestationCollection     *bool                              `json:"hasAttestationCollection,omitempty"`
	HasAttestationCollectionWith []*AttestationCollectionWhereInput `json:"hasAttestationCollectionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AttestationWhereInput) AddPredicates(predicates ...predicate.Attestation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AttestationWhereInput filter on the AttestationQuery builder.
func (i *AttestationWhereInput) Filter(q *AttestationQuery) (*AttestationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAttestationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAttestationWhereInput is returned in case the AttestationWhereInput is empty.
var ErrEmptyAttestationWhereInput = errors.New("ent: empty predicate AttestationWhereInput")

// P returns a predicate for filtering attestations.
// An error is returned if the input is empty or invalid.
func (i *AttestationWhereInput) P() (predicate.Attestation, error) {
	var predicates []predicate.Attestation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, attestation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Attestation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, attestation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Attestation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, attestation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, attestation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, attestation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, attestation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, attestation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, attestation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, attestation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, attestation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, attestation.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, attestation.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, attestation.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, attestation.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, attestation.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, attestation.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, attestation.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, attestation.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, attestation.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, attestation.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, attestation.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, attestation.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, attestation.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, attestation.TypeContainsFold(*i.TypeContainsFold))
	}

	if i.HasOmnitrail != nil {
		p := attestation.HasOmnitrail()
		if !*i.HasOmnitrail {
			p = attestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOmnitrailWith) > 0 {
		with := make([]predicate.Omnitrail, 0, len(i.HasOmnitrailWith))
		for _, w := range i.HasOmnitrailWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOmnitrailWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, attestation.HasOmnitrailWith(with...))
	}
	if i.HasAttestationCollection != nil {
		p := attestation.HasAttestationCollection()
		if !*i.HasAttestationCollection {
			p = attestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAttestationCollectionWith) > 0 {
		with := make([]predicate.AttestationCollection, 0, len(i.HasAttestationCollectionWith))
		for _, w := range i.HasAttestationCollectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAttestationCollectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, attestation.HasAttestationCollectionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAttestationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return attestation.And(predicates...), nil
	}
}

// AttestationCollectionWhereInput represents a where input for filtering AttestationCollection queries.
type AttestationCollectionWhereInput struct {
	Predicates []predicate.AttestationCollection  `json:"-"`
	Not        *AttestationCollectionWhereInput   `json:"not,omitempty"`
	Or         []*AttestationCollectionWhereInput `json:"or,omitempty"`
	And        []*AttestationCollectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "attestations" edge predicates.
	HasAttestations     *bool                    `json:"hasAttestations,omitempty"`
	HasAttestationsWith []*AttestationWhereInput `json:"hasAttestationsWith,omitempty"`

	// "statement" edge predicates.
	HasStatement     *bool                  `json:"hasStatement,omitempty"`
	HasStatementWith []*StatementWhereInput `json:"hasStatementWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AttestationCollectionWhereInput) AddPredicates(predicates ...predicate.AttestationCollection) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AttestationCollectionWhereInput filter on the AttestationCollectionQuery builder.
func (i *AttestationCollectionWhereInput) Filter(q *AttestationCollectionQuery) (*AttestationCollectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAttestationCollectionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAttestationCollectionWhereInput is returned in case the AttestationCollectionWhereInput is empty.
var ErrEmptyAttestationCollectionWhereInput = errors.New("ent: empty predicate AttestationCollectionWhereInput")

// P returns a predicate for filtering attestationcollections.
// An error is returned if the input is empty or invalid.
func (i *AttestationCollectionWhereInput) P() (predicate.AttestationCollection, error) {
	var predicates []predicate.AttestationCollection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, attestationcollection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AttestationCollection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, attestationcollection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AttestationCollection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, attestationcollection.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, attestationcollection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, attestationcollection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, attestationcollection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, attestationcollection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, attestationcollection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, attestationcollection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, attestationcollection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, attestationcollection.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, attestationcollection.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, attestationcollection.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, attestationcollection.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, attestationcollection.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, attestationcollection.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, attestationcollection.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, attestationcollection.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, attestationcollection.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, attestationcollection.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, attestationcollection.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, attestationcollection.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, attestationcollection.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, attestationcollection.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasAttestations != nil {
		p := attestationcollection.HasAttestations()
		if !*i.HasAttestations {
			p = attestationcollection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAttestationsWith) > 0 {
		with := make([]predicate.Attestation, 0, len(i.HasAttestationsWith))
		for _, w := range i.HasAttestationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAttestationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, attestationcollection.HasAttestationsWith(with...))
	}
	if i.HasStatement != nil {
		p := attestationcollection.HasStatement()
		if !*i.HasStatement {
			p = attestationcollection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStatementWith) > 0 {
		with := make([]predicate.Statement, 0, len(i.HasStatementWith))
		for _, w := range i.HasStatementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStatementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, attestationcollection.HasStatementWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAttestationCollectionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return attestationcollection.And(predicates...), nil
	}
}

// AttestationPolicyWhereInput represents a where input for filtering AttestationPolicy queries.
type AttestationPolicyWhereInput struct {
	Predicates []predicate.AttestationPolicy  `json:"-"`
	Not        *AttestationPolicyWhereInput   `json:"not,omitempty"`
	Or         []*AttestationPolicyWhereInput `json:"or,omitempty"`
	And        []*AttestationPolicyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "statement" edge predicates.
	HasStatement     *bool                  `json:"hasStatement,omitempty"`
	HasStatementWith []*StatementWhereInput `json:"hasStatementWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AttestationPolicyWhereInput) AddPredicates(predicates ...predicate.AttestationPolicy) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AttestationPolicyWhereInput filter on the AttestationPolicyQuery builder.
func (i *AttestationPolicyWhereInput) Filter(q *AttestationPolicyQuery) (*AttestationPolicyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAttestationPolicyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAttestationPolicyWhereInput is returned in case the AttestationPolicyWhereInput is empty.
var ErrEmptyAttestationPolicyWhereInput = errors.New("ent: empty predicate AttestationPolicyWhereInput")

// P returns a predicate for filtering attestationpolicies.
// An error is returned if the input is empty or invalid.
func (i *AttestationPolicyWhereInput) P() (predicate.AttestationPolicy, error) {
	var predicates []predicate.AttestationPolicy
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, attestationpolicy.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AttestationPolicy, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, attestationpolicy.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AttestationPolicy, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, attestationpolicy.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, attestationpolicy.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, attestationpolicy.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, attestationpolicy.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, attestationpolicy.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, attestationpolicy.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, attestationpolicy.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, attestationpolicy.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, attestationpolicy.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, attestationpolicy.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, attestationpolicy.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, attestationpolicy.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, attestationpolicy.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, attestationpolicy.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, attestationpolicy.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, attestationpolicy.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, attestationpolicy.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, attestationpolicy.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, attestationpolicy.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, attestationpolicy.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, attestationpolicy.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, attestationpolicy.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasStatement != nil {
		p := attestationpolicy.HasStatement()
		if !*i.HasStatement {
			p = attestationpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStatementWith) > 0 {
		with := make([]predicate.Statement, 0, len(i.HasStatementWith))
		for _, w := range i.HasStatementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStatementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, attestationpolicy.HasStatementWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAttestationPolicyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return attestationpolicy.And(predicates...), nil
	}
}

// DsseWhereInput represents a where input for filtering Dsse queries.
type DsseWhereInput struct {
	Predicates []predicate.Dsse  `json:"-"`
	Not        *DsseWhereInput   `json:"not,omitempty"`
	Or         []*DsseWhereInput `json:"or,omitempty"`
	And        []*DsseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "gitoid_sha256" field predicates.
	GitoidSha256             *string  `json:"gitoidSha256,omitempty"`
	GitoidSha256NEQ          *string  `json:"gitoidSha256NEQ,omitempty"`
	GitoidSha256In           []string `json:"gitoidSha256In,omitempty"`
	GitoidSha256NotIn        []string `json:"gitoidSha256NotIn,omitempty"`
	GitoidSha256GT           *string  `json:"gitoidSha256GT,omitempty"`
	GitoidSha256GTE          *string  `json:"gitoidSha256GTE,omitempty"`
	GitoidSha256LT           *string  `json:"gitoidSha256LT,omitempty"`
	GitoidSha256LTE          *string  `json:"gitoidSha256LTE,omitempty"`
	GitoidSha256Contains     *string  `json:"gitoidSha256Contains,omitempty"`
	GitoidSha256HasPrefix    *string  `json:"gitoidSha256HasPrefix,omitempty"`
	GitoidSha256HasSuffix    *string  `json:"gitoidSha256HasSuffix,omitempty"`
	GitoidSha256EqualFold    *string  `json:"gitoidSha256EqualFold,omitempty"`
	GitoidSha256ContainsFold *string  `json:"gitoidSha256ContainsFold,omitempty"`

	// "payload_type" field predicates.
	PayloadType             *string  `json:"payloadType,omitempty"`
	PayloadTypeNEQ          *string  `json:"payloadTypeNEQ,omitempty"`
	PayloadTypeIn           []string `json:"payloadTypeIn,omitempty"`
	PayloadTypeNotIn        []string `json:"payloadTypeNotIn,omitempty"`
	PayloadTypeGT           *string  `json:"payloadTypeGT,omitempty"`
	PayloadTypeGTE          *string  `json:"payloadTypeGTE,omitempty"`
	PayloadTypeLT           *string  `json:"payloadTypeLT,omitempty"`
	PayloadTypeLTE          *string  `json:"payloadTypeLTE,omitempty"`
	PayloadTypeContains     *string  `json:"payloadTypeContains,omitempty"`
	PayloadTypeHasPrefix    *string  `json:"payloadTypeHasPrefix,omitempty"`
	PayloadTypeHasSuffix    *string  `json:"payloadTypeHasSuffix,omitempty"`
	PayloadTypeEqualFold    *string  `json:"payloadTypeEqualFold,omitempty"`
	PayloadTypeContainsFold *string  `json:"payloadTypeContainsFold,omitempty"`

	// "statement" edge predicates.
	HasStatement     *bool                  `json:"hasStatement,omitempty"`
	HasStatementWith []*StatementWhereInput `json:"hasStatementWith,omitempty"`

	// "signatures" edge predicates.
	HasSignatures     *bool                  `json:"hasSignatures,omitempty"`
	HasSignaturesWith []*SignatureWhereInput `json:"hasSignaturesWith,omitempty"`

	// "payload_digests" edge predicates.
	HasPayloadDigests     *bool                      `json:"hasPayloadDigests,omitempty"`
	HasPayloadDigestsWith []*PayloadDigestWhereInput `json:"hasPayloadDigestsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DsseWhereInput) AddPredicates(predicates ...predicate.Dsse) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DsseWhereInput filter on the DsseQuery builder.
func (i *DsseWhereInput) Filter(q *DsseQuery) (*DsseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDsseWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDsseWhereInput is returned in case the DsseWhereInput is empty.
var ErrEmptyDsseWhereInput = errors.New("ent: empty predicate DsseWhereInput")

// P returns a predicate for filtering dsses.
// An error is returned if the input is empty or invalid.
func (i *DsseWhereInput) P() (predicate.Dsse, error) {
	var predicates []predicate.Dsse
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dsse.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Dsse, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dsse.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Dsse, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dsse.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dsse.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dsse.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dsse.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dsse.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dsse.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dsse.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dsse.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dsse.IDLTE(*i.IDLTE))
	}
	if i.GitoidSha256 != nil {
		predicates = append(predicates, dsse.GitoidSha256EQ(*i.GitoidSha256))
	}
	if i.GitoidSha256NEQ != nil {
		predicates = append(predicates, dsse.GitoidSha256NEQ(*i.GitoidSha256NEQ))
	}
	if len(i.GitoidSha256In) > 0 {
		predicates = append(predicates, dsse.GitoidSha256In(i.GitoidSha256In...))
	}
	if len(i.GitoidSha256NotIn) > 0 {
		predicates = append(predicates, dsse.GitoidSha256NotIn(i.GitoidSha256NotIn...))
	}
	if i.GitoidSha256GT != nil {
		predicates = append(predicates, dsse.GitoidSha256GT(*i.GitoidSha256GT))
	}
	if i.GitoidSha256GTE != nil {
		predicates = append(predicates, dsse.GitoidSha256GTE(*i.GitoidSha256GTE))
	}
	if i.GitoidSha256LT != nil {
		predicates = append(predicates, dsse.GitoidSha256LT(*i.GitoidSha256LT))
	}
	if i.GitoidSha256LTE != nil {
		predicates = append(predicates, dsse.GitoidSha256LTE(*i.GitoidSha256LTE))
	}
	if i.GitoidSha256Contains != nil {
		predicates = append(predicates, dsse.GitoidSha256Contains(*i.GitoidSha256Contains))
	}
	if i.GitoidSha256HasPrefix != nil {
		predicates = append(predicates, dsse.GitoidSha256HasPrefix(*i.GitoidSha256HasPrefix))
	}
	if i.GitoidSha256HasSuffix != nil {
		predicates = append(predicates, dsse.GitoidSha256HasSuffix(*i.GitoidSha256HasSuffix))
	}
	if i.GitoidSha256EqualFold != nil {
		predicates = append(predicates, dsse.GitoidSha256EqualFold(*i.GitoidSha256EqualFold))
	}
	if i.GitoidSha256ContainsFold != nil {
		predicates = append(predicates, dsse.GitoidSha256ContainsFold(*i.GitoidSha256ContainsFold))
	}
	if i.PayloadType != nil {
		predicates = append(predicates, dsse.PayloadTypeEQ(*i.PayloadType))
	}
	if i.PayloadTypeNEQ != nil {
		predicates = append(predicates, dsse.PayloadTypeNEQ(*i.PayloadTypeNEQ))
	}
	if len(i.PayloadTypeIn) > 0 {
		predicates = append(predicates, dsse.PayloadTypeIn(i.PayloadTypeIn...))
	}
	if len(i.PayloadTypeNotIn) > 0 {
		predicates = append(predicates, dsse.PayloadTypeNotIn(i.PayloadTypeNotIn...))
	}
	if i.PayloadTypeGT != nil {
		predicates = append(predicates, dsse.PayloadTypeGT(*i.PayloadTypeGT))
	}
	if i.PayloadTypeGTE != nil {
		predicates = append(predicates, dsse.PayloadTypeGTE(*i.PayloadTypeGTE))
	}
	if i.PayloadTypeLT != nil {
		predicates = append(predicates, dsse.PayloadTypeLT(*i.PayloadTypeLT))
	}
	if i.PayloadTypeLTE != nil {
		predicates = append(predicates, dsse.PayloadTypeLTE(*i.PayloadTypeLTE))
	}
	if i.PayloadTypeContains != nil {
		predicates = append(predicates, dsse.PayloadTypeContains(*i.PayloadTypeContains))
	}
	if i.PayloadTypeHasPrefix != nil {
		predicates = append(predicates, dsse.PayloadTypeHasPrefix(*i.PayloadTypeHasPrefix))
	}
	if i.PayloadTypeHasSuffix != nil {
		predicates = append(predicates, dsse.PayloadTypeHasSuffix(*i.PayloadTypeHasSuffix))
	}
	if i.PayloadTypeEqualFold != nil {
		predicates = append(predicates, dsse.PayloadTypeEqualFold(*i.PayloadTypeEqualFold))
	}
	if i.PayloadTypeContainsFold != nil {
		predicates = append(predicates, dsse.PayloadTypeContainsFold(*i.PayloadTypeContainsFold))
	}

	if i.HasStatement != nil {
		p := dsse.HasStatement()
		if !*i.HasStatement {
			p = dsse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStatementWith) > 0 {
		with := make([]predicate.Statement, 0, len(i.HasStatementWith))
		for _, w := range i.HasStatementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStatementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dsse.HasStatementWith(with...))
	}
	if i.HasSignatures != nil {
		p := dsse.HasSignatures()
		if !*i.HasSignatures {
			p = dsse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSignaturesWith) > 0 {
		with := make([]predicate.Signature, 0, len(i.HasSignaturesWith))
		for _, w := range i.HasSignaturesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSignaturesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dsse.HasSignaturesWith(with...))
	}
	if i.HasPayloadDigests != nil {
		p := dsse.HasPayloadDigests()
		if !*i.HasPayloadDigests {
			p = dsse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPayloadDigestsWith) > 0 {
		with := make([]predicate.PayloadDigest, 0, len(i.HasPayloadDigestsWith))
		for _, w := range i.HasPayloadDigestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPayloadDigestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dsse.HasPayloadDigestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDsseWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dsse.And(predicates...), nil
	}
}

// MappingWhereInput represents a where input for filtering Mapping queries.
type MappingWhereInput struct {
	Predicates []predicate.Mapping  `json:"-"`
	Not        *MappingWhereInput   `json:"not,omitempty"`
	Or         []*MappingWhereInput `json:"or,omitempty"`
	And        []*MappingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "path" field predicates.
	Path             *string  `json:"path,omitempty"`
	PathNEQ          *string  `json:"pathNEQ,omitempty"`
	PathIn           []string `json:"pathIn,omitempty"`
	PathNotIn        []string `json:"pathNotIn,omitempty"`
	PathGT           *string  `json:"pathGT,omitempty"`
	PathGTE          *string  `json:"pathGTE,omitempty"`
	PathLT           *string  `json:"pathLT,omitempty"`
	PathLTE          *string  `json:"pathLTE,omitempty"`
	PathContains     *string  `json:"pathContains,omitempty"`
	PathHasPrefix    *string  `json:"pathHasPrefix,omitempty"`
	PathHasSuffix    *string  `json:"pathHasSuffix,omitempty"`
	PathEqualFold    *string  `json:"pathEqualFold,omitempty"`
	PathContainsFold *string  `json:"pathContainsFold,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "sha1" field predicates.
	Sha1             *string  `json:"sha1,omitempty"`
	Sha1NEQ          *string  `json:"sha1NEQ,omitempty"`
	Sha1In           []string `json:"sha1In,omitempty"`
	Sha1NotIn        []string `json:"sha1NotIn,omitempty"`
	Sha1GT           *string  `json:"sha1GT,omitempty"`
	Sha1GTE          *string  `json:"sha1GTE,omitempty"`
	Sha1LT           *string  `json:"sha1LT,omitempty"`
	Sha1LTE          *string  `json:"sha1LTE,omitempty"`
	Sha1Contains     *string  `json:"sha1Contains,omitempty"`
	Sha1HasPrefix    *string  `json:"sha1HasPrefix,omitempty"`
	Sha1HasSuffix    *string  `json:"sha1HasSuffix,omitempty"`
	Sha1EqualFold    *string  `json:"sha1EqualFold,omitempty"`
	Sha1ContainsFold *string  `json:"sha1ContainsFold,omitempty"`

	// "sha256" field predicates.
	Sha256             *string  `json:"sha256,omitempty"`
	Sha256NEQ          *string  `json:"sha256NEQ,omitempty"`
	Sha256In           []string `json:"sha256In,omitempty"`
	Sha256NotIn        []string `json:"sha256NotIn,omitempty"`
	Sha256GT           *string  `json:"sha256GT,omitempty"`
	Sha256GTE          *string  `json:"sha256GTE,omitempty"`
	Sha256LT           *string  `json:"sha256LT,omitempty"`
	Sha256LTE          *string  `json:"sha256LTE,omitempty"`
	Sha256Contains     *string  `json:"sha256Contains,omitempty"`
	Sha256HasPrefix    *string  `json:"sha256HasPrefix,omitempty"`
	Sha256HasSuffix    *string  `json:"sha256HasSuffix,omitempty"`
	Sha256EqualFold    *string  `json:"sha256EqualFold,omitempty"`
	Sha256ContainsFold *string  `json:"sha256ContainsFold,omitempty"`

	// "gitoidSha1" field predicates.
	GitoidSha1             *string  `json:"gitoidsha1,omitempty"`
	GitoidSha1NEQ          *string  `json:"gitoidsha1NEQ,omitempty"`
	GitoidSha1In           []string `json:"gitoidsha1In,omitempty"`
	GitoidSha1NotIn        []string `json:"gitoidsha1NotIn,omitempty"`
	GitoidSha1GT           *string  `json:"gitoidsha1GT,omitempty"`
	GitoidSha1GTE          *string  `json:"gitoidsha1GTE,omitempty"`
	GitoidSha1LT           *string  `json:"gitoidsha1LT,omitempty"`
	GitoidSha1LTE          *string  `json:"gitoidsha1LTE,omitempty"`
	GitoidSha1Contains     *string  `json:"gitoidsha1Contains,omitempty"`
	GitoidSha1HasPrefix    *string  `json:"gitoidsha1HasPrefix,omitempty"`
	GitoidSha1HasSuffix    *string  `json:"gitoidsha1HasSuffix,omitempty"`
	GitoidSha1EqualFold    *string  `json:"gitoidsha1EqualFold,omitempty"`
	GitoidSha1ContainsFold *string  `json:"gitoidsha1ContainsFold,omitempty"`

	// "gitoidSha256" field predicates.
	GitoidSha256             *string  `json:"gitoidsha256,omitempty"`
	GitoidSha256NEQ          *string  `json:"gitoidsha256NEQ,omitempty"`
	GitoidSha256In           []string `json:"gitoidsha256In,omitempty"`
	GitoidSha256NotIn        []string `json:"gitoidsha256NotIn,omitempty"`
	GitoidSha256GT           *string  `json:"gitoidsha256GT,omitempty"`
	GitoidSha256GTE          *string  `json:"gitoidsha256GTE,omitempty"`
	GitoidSha256LT           *string  `json:"gitoidsha256LT,omitempty"`
	GitoidSha256LTE          *string  `json:"gitoidsha256LTE,omitempty"`
	GitoidSha256Contains     *string  `json:"gitoidsha256Contains,omitempty"`
	GitoidSha256HasPrefix    *string  `json:"gitoidsha256HasPrefix,omitempty"`
	GitoidSha256HasSuffix    *string  `json:"gitoidsha256HasSuffix,omitempty"`
	GitoidSha256EqualFold    *string  `json:"gitoidsha256EqualFold,omitempty"`
	GitoidSha256ContainsFold *string  `json:"gitoidsha256ContainsFold,omitempty"`

	// "posix" edge predicates.
	HasPosix     *bool              `json:"hasPosix,omitempty"`
	HasPosixWith []*PosixWhereInput `json:"hasPosixWith,omitempty"`

	// "omnitrail" edge predicates.
	HasOmnitrail     *bool                  `json:"hasOmnitrail,omitempty"`
	HasOmnitrailWith []*OmnitrailWhereInput `json:"hasOmnitrailWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MappingWhereInput) AddPredicates(predicates ...predicate.Mapping) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MappingWhereInput filter on the MappingQuery builder.
func (i *MappingWhereInput) Filter(q *MappingQuery) (*MappingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMappingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMappingWhereInput is returned in case the MappingWhereInput is empty.
var ErrEmptyMappingWhereInput = errors.New("ent: empty predicate MappingWhereInput")

// P returns a predicate for filtering mappings.
// An error is returned if the input is empty or invalid.
func (i *MappingWhereInput) P() (predicate.Mapping, error) {
	var predicates []predicate.Mapping
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, mapping.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Mapping, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, mapping.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Mapping, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, mapping.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, mapping.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, mapping.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, mapping.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, mapping.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, mapping.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, mapping.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, mapping.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, mapping.IDLTE(*i.IDLTE))
	}
	if i.Path != nil {
		predicates = append(predicates, mapping.PathEQ(*i.Path))
	}
	if i.PathNEQ != nil {
		predicates = append(predicates, mapping.PathNEQ(*i.PathNEQ))
	}
	if len(i.PathIn) > 0 {
		predicates = append(predicates, mapping.PathIn(i.PathIn...))
	}
	if len(i.PathNotIn) > 0 {
		predicates = append(predicates, mapping.PathNotIn(i.PathNotIn...))
	}
	if i.PathGT != nil {
		predicates = append(predicates, mapping.PathGT(*i.PathGT))
	}
	if i.PathGTE != nil {
		predicates = append(predicates, mapping.PathGTE(*i.PathGTE))
	}
	if i.PathLT != nil {
		predicates = append(predicates, mapping.PathLT(*i.PathLT))
	}
	if i.PathLTE != nil {
		predicates = append(predicates, mapping.PathLTE(*i.PathLTE))
	}
	if i.PathContains != nil {
		predicates = append(predicates, mapping.PathContains(*i.PathContains))
	}
	if i.PathHasPrefix != nil {
		predicates = append(predicates, mapping.PathHasPrefix(*i.PathHasPrefix))
	}
	if i.PathHasSuffix != nil {
		predicates = append(predicates, mapping.PathHasSuffix(*i.PathHasSuffix))
	}
	if i.PathEqualFold != nil {
		predicates = append(predicates, mapping.PathEqualFold(*i.PathEqualFold))
	}
	if i.PathContainsFold != nil {
		predicates = append(predicates, mapping.PathContainsFold(*i.PathContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, mapping.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, mapping.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, mapping.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, mapping.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, mapping.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, mapping.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, mapping.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, mapping.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, mapping.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, mapping.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, mapping.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, mapping.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, mapping.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.Sha1 != nil {
		predicates = append(predicates, mapping.Sha1EQ(*i.Sha1))
	}
	if i.Sha1NEQ != nil {
		predicates = append(predicates, mapping.Sha1NEQ(*i.Sha1NEQ))
	}
	if len(i.Sha1In) > 0 {
		predicates = append(predicates, mapping.Sha1In(i.Sha1In...))
	}
	if len(i.Sha1NotIn) > 0 {
		predicates = append(predicates, mapping.Sha1NotIn(i.Sha1NotIn...))
	}
	if i.Sha1GT != nil {
		predicates = append(predicates, mapping.Sha1GT(*i.Sha1GT))
	}
	if i.Sha1GTE != nil {
		predicates = append(predicates, mapping.Sha1GTE(*i.Sha1GTE))
	}
	if i.Sha1LT != nil {
		predicates = append(predicates, mapping.Sha1LT(*i.Sha1LT))
	}
	if i.Sha1LTE != nil {
		predicates = append(predicates, mapping.Sha1LTE(*i.Sha1LTE))
	}
	if i.Sha1Contains != nil {
		predicates = append(predicates, mapping.Sha1Contains(*i.Sha1Contains))
	}
	if i.Sha1HasPrefix != nil {
		predicates = append(predicates, mapping.Sha1HasPrefix(*i.Sha1HasPrefix))
	}
	if i.Sha1HasSuffix != nil {
		predicates = append(predicates, mapping.Sha1HasSuffix(*i.Sha1HasSuffix))
	}
	if i.Sha1EqualFold != nil {
		predicates = append(predicates, mapping.Sha1EqualFold(*i.Sha1EqualFold))
	}
	if i.Sha1ContainsFold != nil {
		predicates = append(predicates, mapping.Sha1ContainsFold(*i.Sha1ContainsFold))
	}
	if i.Sha256 != nil {
		predicates = append(predicates, mapping.Sha256EQ(*i.Sha256))
	}
	if i.Sha256NEQ != nil {
		predicates = append(predicates, mapping.Sha256NEQ(*i.Sha256NEQ))
	}
	if len(i.Sha256In) > 0 {
		predicates = append(predicates, mapping.Sha256In(i.Sha256In...))
	}
	if len(i.Sha256NotIn) > 0 {
		predicates = append(predicates, mapping.Sha256NotIn(i.Sha256NotIn...))
	}
	if i.Sha256GT != nil {
		predicates = append(predicates, mapping.Sha256GT(*i.Sha256GT))
	}
	if i.Sha256GTE != nil {
		predicates = append(predicates, mapping.Sha256GTE(*i.Sha256GTE))
	}
	if i.Sha256LT != nil {
		predicates = append(predicates, mapping.Sha256LT(*i.Sha256LT))
	}
	if i.Sha256LTE != nil {
		predicates = append(predicates, mapping.Sha256LTE(*i.Sha256LTE))
	}
	if i.Sha256Contains != nil {
		predicates = append(predicates, mapping.Sha256Contains(*i.Sha256Contains))
	}
	if i.Sha256HasPrefix != nil {
		predicates = append(predicates, mapping.Sha256HasPrefix(*i.Sha256HasPrefix))
	}
	if i.Sha256HasSuffix != nil {
		predicates = append(predicates, mapping.Sha256HasSuffix(*i.Sha256HasSuffix))
	}
	if i.Sha256EqualFold != nil {
		predicates = append(predicates, mapping.Sha256EqualFold(*i.Sha256EqualFold))
	}
	if i.Sha256ContainsFold != nil {
		predicates = append(predicates, mapping.Sha256ContainsFold(*i.Sha256ContainsFold))
	}
	if i.GitoidSha1 != nil {
		predicates = append(predicates, mapping.GitoidSha1EQ(*i.GitoidSha1))
	}
	if i.GitoidSha1NEQ != nil {
		predicates = append(predicates, mapping.GitoidSha1NEQ(*i.GitoidSha1NEQ))
	}
	if len(i.GitoidSha1In) > 0 {
		predicates = append(predicates, mapping.GitoidSha1In(i.GitoidSha1In...))
	}
	if len(i.GitoidSha1NotIn) > 0 {
		predicates = append(predicates, mapping.GitoidSha1NotIn(i.GitoidSha1NotIn...))
	}
	if i.GitoidSha1GT != nil {
		predicates = append(predicates, mapping.GitoidSha1GT(*i.GitoidSha1GT))
	}
	if i.GitoidSha1GTE != nil {
		predicates = append(predicates, mapping.GitoidSha1GTE(*i.GitoidSha1GTE))
	}
	if i.GitoidSha1LT != nil {
		predicates = append(predicates, mapping.GitoidSha1LT(*i.GitoidSha1LT))
	}
	if i.GitoidSha1LTE != nil {
		predicates = append(predicates, mapping.GitoidSha1LTE(*i.GitoidSha1LTE))
	}
	if i.GitoidSha1Contains != nil {
		predicates = append(predicates, mapping.GitoidSha1Contains(*i.GitoidSha1Contains))
	}
	if i.GitoidSha1HasPrefix != nil {
		predicates = append(predicates, mapping.GitoidSha1HasPrefix(*i.GitoidSha1HasPrefix))
	}
	if i.GitoidSha1HasSuffix != nil {
		predicates = append(predicates, mapping.GitoidSha1HasSuffix(*i.GitoidSha1HasSuffix))
	}
	if i.GitoidSha1EqualFold != nil {
		predicates = append(predicates, mapping.GitoidSha1EqualFold(*i.GitoidSha1EqualFold))
	}
	if i.GitoidSha1ContainsFold != nil {
		predicates = append(predicates, mapping.GitoidSha1ContainsFold(*i.GitoidSha1ContainsFold))
	}
	if i.GitoidSha256 != nil {
		predicates = append(predicates, mapping.GitoidSha256EQ(*i.GitoidSha256))
	}
	if i.GitoidSha256NEQ != nil {
		predicates = append(predicates, mapping.GitoidSha256NEQ(*i.GitoidSha256NEQ))
	}
	if len(i.GitoidSha256In) > 0 {
		predicates = append(predicates, mapping.GitoidSha256In(i.GitoidSha256In...))
	}
	if len(i.GitoidSha256NotIn) > 0 {
		predicates = append(predicates, mapping.GitoidSha256NotIn(i.GitoidSha256NotIn...))
	}
	if i.GitoidSha256GT != nil {
		predicates = append(predicates, mapping.GitoidSha256GT(*i.GitoidSha256GT))
	}
	if i.GitoidSha256GTE != nil {
		predicates = append(predicates, mapping.GitoidSha256GTE(*i.GitoidSha256GTE))
	}
	if i.GitoidSha256LT != nil {
		predicates = append(predicates, mapping.GitoidSha256LT(*i.GitoidSha256LT))
	}
	if i.GitoidSha256LTE != nil {
		predicates = append(predicates, mapping.GitoidSha256LTE(*i.GitoidSha256LTE))
	}
	if i.GitoidSha256Contains != nil {
		predicates = append(predicates, mapping.GitoidSha256Contains(*i.GitoidSha256Contains))
	}
	if i.GitoidSha256HasPrefix != nil {
		predicates = append(predicates, mapping.GitoidSha256HasPrefix(*i.GitoidSha256HasPrefix))
	}
	if i.GitoidSha256HasSuffix != nil {
		predicates = append(predicates, mapping.GitoidSha256HasSuffix(*i.GitoidSha256HasSuffix))
	}
	if i.GitoidSha256EqualFold != nil {
		predicates = append(predicates, mapping.GitoidSha256EqualFold(*i.GitoidSha256EqualFold))
	}
	if i.GitoidSha256ContainsFold != nil {
		predicates = append(predicates, mapping.GitoidSha256ContainsFold(*i.GitoidSha256ContainsFold))
	}

	if i.HasPosix != nil {
		p := mapping.HasPosix()
		if !*i.HasPosix {
			p = mapping.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPosixWith) > 0 {
		with := make([]predicate.Posix, 0, len(i.HasPosixWith))
		for _, w := range i.HasPosixWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPosixWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mapping.HasPosixWith(with...))
	}
	if i.HasOmnitrail != nil {
		p := mapping.HasOmnitrail()
		if !*i.HasOmnitrail {
			p = mapping.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOmnitrailWith) > 0 {
		with := make([]predicate.Omnitrail, 0, len(i.HasOmnitrailWith))
		for _, w := range i.HasOmnitrailWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOmnitrailWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mapping.HasOmnitrailWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMappingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return mapping.And(predicates...), nil
	}
}

// OmnitrailWhereInput represents a where input for filtering Omnitrail queries.
type OmnitrailWhereInput struct {
	Predicates []predicate.Omnitrail  `json:"-"`
	Not        *OmnitrailWhereInput   `json:"not,omitempty"`
	Or         []*OmnitrailWhereInput `json:"or,omitempty"`
	And        []*OmnitrailWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "mappings" edge predicates.
	HasMappings     *bool                `json:"hasMappings,omitempty"`
	HasMappingsWith []*MappingWhereInput `json:"hasMappingsWith,omitempty"`

	// "attestation" edge predicates.
	HasAttestation     *bool                    `json:"hasAttestation,omitempty"`
	HasAttestationWith []*AttestationWhereInput `json:"hasAttestationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OmnitrailWhereInput) AddPredicates(predicates ...predicate.Omnitrail) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OmnitrailWhereInput filter on the OmnitrailQuery builder.
func (i *OmnitrailWhereInput) Filter(q *OmnitrailQuery) (*OmnitrailQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOmnitrailWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOmnitrailWhereInput is returned in case the OmnitrailWhereInput is empty.
var ErrEmptyOmnitrailWhereInput = errors.New("ent: empty predicate OmnitrailWhereInput")

// P returns a predicate for filtering omnitrails.
// An error is returned if the input is empty or invalid.
func (i *OmnitrailWhereInput) P() (predicate.Omnitrail, error) {
	var predicates []predicate.Omnitrail
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, omnitrail.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Omnitrail, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, omnitrail.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Omnitrail, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, omnitrail.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, omnitrail.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, omnitrail.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, omnitrail.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, omnitrail.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, omnitrail.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, omnitrail.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, omnitrail.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, omnitrail.IDLTE(*i.IDLTE))
	}

	if i.HasMappings != nil {
		p := omnitrail.HasMappings()
		if !*i.HasMappings {
			p = omnitrail.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMappingsWith) > 0 {
		with := make([]predicate.Mapping, 0, len(i.HasMappingsWith))
		for _, w := range i.HasMappingsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMappingsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, omnitrail.HasMappingsWith(with...))
	}
	if i.HasAttestation != nil {
		p := omnitrail.HasAttestation()
		if !*i.HasAttestation {
			p = omnitrail.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAttestationWith) > 0 {
		with := make([]predicate.Attestation, 0, len(i.HasAttestationWith))
		for _, w := range i.HasAttestationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAttestationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, omnitrail.HasAttestationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOmnitrailWhereInput
	case 1:
		return predicates[0], nil
	default:
		return omnitrail.And(predicates...), nil
	}
}

// PayloadDigestWhereInput represents a where input for filtering PayloadDigest queries.
type PayloadDigestWhereInput struct {
	Predicates []predicate.PayloadDigest  `json:"-"`
	Not        *PayloadDigestWhereInput   `json:"not,omitempty"`
	Or         []*PayloadDigestWhereInput `json:"or,omitempty"`
	And        []*PayloadDigestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "algorithm" field predicates.
	Algorithm             *string  `json:"algorithm,omitempty"`
	AlgorithmNEQ          *string  `json:"algorithmNEQ,omitempty"`
	AlgorithmIn           []string `json:"algorithmIn,omitempty"`
	AlgorithmNotIn        []string `json:"algorithmNotIn,omitempty"`
	AlgorithmGT           *string  `json:"algorithmGT,omitempty"`
	AlgorithmGTE          *string  `json:"algorithmGTE,omitempty"`
	AlgorithmLT           *string  `json:"algorithmLT,omitempty"`
	AlgorithmLTE          *string  `json:"algorithmLTE,omitempty"`
	AlgorithmContains     *string  `json:"algorithmContains,omitempty"`
	AlgorithmHasPrefix    *string  `json:"algorithmHasPrefix,omitempty"`
	AlgorithmHasSuffix    *string  `json:"algorithmHasSuffix,omitempty"`
	AlgorithmEqualFold    *string  `json:"algorithmEqualFold,omitempty"`
	AlgorithmContainsFold *string  `json:"algorithmContainsFold,omitempty"`

	// "value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`

	// "dsse" edge predicates.
	HasDsse     *bool             `json:"hasDsse,omitempty"`
	HasDsseWith []*DsseWhereInput `json:"hasDsseWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PayloadDigestWhereInput) AddPredicates(predicates ...predicate.PayloadDigest) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PayloadDigestWhereInput filter on the PayloadDigestQuery builder.
func (i *PayloadDigestWhereInput) Filter(q *PayloadDigestQuery) (*PayloadDigestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPayloadDigestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPayloadDigestWhereInput is returned in case the PayloadDigestWhereInput is empty.
var ErrEmptyPayloadDigestWhereInput = errors.New("ent: empty predicate PayloadDigestWhereInput")

// P returns a predicate for filtering payloaddigests.
// An error is returned if the input is empty or invalid.
func (i *PayloadDigestWhereInput) P() (predicate.PayloadDigest, error) {
	var predicates []predicate.PayloadDigest
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, payloaddigest.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PayloadDigest, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, payloaddigest.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PayloadDigest, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, payloaddigest.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, payloaddigest.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, payloaddigest.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, payloaddigest.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, payloaddigest.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, payloaddigest.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, payloaddigest.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, payloaddigest.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, payloaddigest.IDLTE(*i.IDLTE))
	}
	if i.Algorithm != nil {
		predicates = append(predicates, payloaddigest.AlgorithmEQ(*i.Algorithm))
	}
	if i.AlgorithmNEQ != nil {
		predicates = append(predicates, payloaddigest.AlgorithmNEQ(*i.AlgorithmNEQ))
	}
	if len(i.AlgorithmIn) > 0 {
		predicates = append(predicates, payloaddigest.AlgorithmIn(i.AlgorithmIn...))
	}
	if len(i.AlgorithmNotIn) > 0 {
		predicates = append(predicates, payloaddigest.AlgorithmNotIn(i.AlgorithmNotIn...))
	}
	if i.AlgorithmGT != nil {
		predicates = append(predicates, payloaddigest.AlgorithmGT(*i.AlgorithmGT))
	}
	if i.AlgorithmGTE != nil {
		predicates = append(predicates, payloaddigest.AlgorithmGTE(*i.AlgorithmGTE))
	}
	if i.AlgorithmLT != nil {
		predicates = append(predicates, payloaddigest.AlgorithmLT(*i.AlgorithmLT))
	}
	if i.AlgorithmLTE != nil {
		predicates = append(predicates, payloaddigest.AlgorithmLTE(*i.AlgorithmLTE))
	}
	if i.AlgorithmContains != nil {
		predicates = append(predicates, payloaddigest.AlgorithmContains(*i.AlgorithmContains))
	}
	if i.AlgorithmHasPrefix != nil {
		predicates = append(predicates, payloaddigest.AlgorithmHasPrefix(*i.AlgorithmHasPrefix))
	}
	if i.AlgorithmHasSuffix != nil {
		predicates = append(predicates, payloaddigest.AlgorithmHasSuffix(*i.AlgorithmHasSuffix))
	}
	if i.AlgorithmEqualFold != nil {
		predicates = append(predicates, payloaddigest.AlgorithmEqualFold(*i.AlgorithmEqualFold))
	}
	if i.AlgorithmContainsFold != nil {
		predicates = append(predicates, payloaddigest.AlgorithmContainsFold(*i.AlgorithmContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, payloaddigest.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, payloaddigest.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, payloaddigest.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, payloaddigest.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, payloaddigest.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, payloaddigest.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, payloaddigest.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, payloaddigest.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, payloaddigest.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, payloaddigest.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, payloaddigest.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, payloaddigest.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, payloaddigest.ValueContainsFold(*i.ValueContainsFold))
	}

	if i.HasDsse != nil {
		p := payloaddigest.HasDsse()
		if !*i.HasDsse {
			p = payloaddigest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDsseWith) > 0 {
		with := make([]predicate.Dsse, 0, len(i.HasDsseWith))
		for _, w := range i.HasDsseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDsseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, payloaddigest.HasDsseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPayloadDigestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return payloaddigest.And(predicates...), nil
	}
}

// PosixWhereInput represents a where input for filtering Posix queries.
type PosixWhereInput struct {
	Predicates []predicate.Posix  `json:"-"`
	Not        *PosixWhereInput   `json:"not,omitempty"`
	Or         []*PosixWhereInput `json:"or,omitempty"`
	And        []*PosixWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "atime" field predicates.
	Atime             *string  `json:"atime,omitempty"`
	AtimeNEQ          *string  `json:"atimeNEQ,omitempty"`
	AtimeIn           []string `json:"atimeIn,omitempty"`
	AtimeNotIn        []string `json:"atimeNotIn,omitempty"`
	AtimeGT           *string  `json:"atimeGT,omitempty"`
	AtimeGTE          *string  `json:"atimeGTE,omitempty"`
	AtimeLT           *string  `json:"atimeLT,omitempty"`
	AtimeLTE          *string  `json:"atimeLTE,omitempty"`
	AtimeContains     *string  `json:"atimeContains,omitempty"`
	AtimeHasPrefix    *string  `json:"atimeHasPrefix,omitempty"`
	AtimeHasSuffix    *string  `json:"atimeHasSuffix,omitempty"`
	AtimeEqualFold    *string  `json:"atimeEqualFold,omitempty"`
	AtimeContainsFold *string  `json:"atimeContainsFold,omitempty"`

	// "ctime" field predicates.
	Ctime             *string  `json:"ctime,omitempty"`
	CtimeNEQ          *string  `json:"ctimeNEQ,omitempty"`
	CtimeIn           []string `json:"ctimeIn,omitempty"`
	CtimeNotIn        []string `json:"ctimeNotIn,omitempty"`
	CtimeGT           *string  `json:"ctimeGT,omitempty"`
	CtimeGTE          *string  `json:"ctimeGTE,omitempty"`
	CtimeLT           *string  `json:"ctimeLT,omitempty"`
	CtimeLTE          *string  `json:"ctimeLTE,omitempty"`
	CtimeContains     *string  `json:"ctimeContains,omitempty"`
	CtimeHasPrefix    *string  `json:"ctimeHasPrefix,omitempty"`
	CtimeHasSuffix    *string  `json:"ctimeHasSuffix,omitempty"`
	CtimeEqualFold    *string  `json:"ctimeEqualFold,omitempty"`
	CtimeContainsFold *string  `json:"ctimeContainsFold,omitempty"`

	// "creation_time" field predicates.
	CreationTime             *string  `json:"creationTime,omitempty"`
	CreationTimeNEQ          *string  `json:"creationTimeNEQ,omitempty"`
	CreationTimeIn           []string `json:"creationTimeIn,omitempty"`
	CreationTimeNotIn        []string `json:"creationTimeNotIn,omitempty"`
	CreationTimeGT           *string  `json:"creationTimeGT,omitempty"`
	CreationTimeGTE          *string  `json:"creationTimeGTE,omitempty"`
	CreationTimeLT           *string  `json:"creationTimeLT,omitempty"`
	CreationTimeLTE          *string  `json:"creationTimeLTE,omitempty"`
	CreationTimeContains     *string  `json:"creationTimeContains,omitempty"`
	CreationTimeHasPrefix    *string  `json:"creationTimeHasPrefix,omitempty"`
	CreationTimeHasSuffix    *string  `json:"creationTimeHasSuffix,omitempty"`
	CreationTimeEqualFold    *string  `json:"creationTimeEqualFold,omitempty"`
	CreationTimeContainsFold *string  `json:"creationTimeContainsFold,omitempty"`

	// "extended_attributes" field predicates.
	ExtendedAttributes             *string  `json:"extendedAttributes,omitempty"`
	ExtendedAttributesNEQ          *string  `json:"extendedAttributesNEQ,omitempty"`
	ExtendedAttributesIn           []string `json:"extendedAttributesIn,omitempty"`
	ExtendedAttributesNotIn        []string `json:"extendedAttributesNotIn,omitempty"`
	ExtendedAttributesGT           *string  `json:"extendedAttributesGT,omitempty"`
	ExtendedAttributesGTE          *string  `json:"extendedAttributesGTE,omitempty"`
	ExtendedAttributesLT           *string  `json:"extendedAttributesLT,omitempty"`
	ExtendedAttributesLTE          *string  `json:"extendedAttributesLTE,omitempty"`
	ExtendedAttributesContains     *string  `json:"extendedAttributesContains,omitempty"`
	ExtendedAttributesHasPrefix    *string  `json:"extendedAttributesHasPrefix,omitempty"`
	ExtendedAttributesHasSuffix    *string  `json:"extendedAttributesHasSuffix,omitempty"`
	ExtendedAttributesEqualFold    *string  `json:"extendedAttributesEqualFold,omitempty"`
	ExtendedAttributesContainsFold *string  `json:"extendedAttributesContainsFold,omitempty"`

	// "file_device_id" field predicates.
	FileDeviceID             *string  `json:"fileDeviceID,omitempty"`
	FileDeviceIDNEQ          *string  `json:"fileDeviceIDNEQ,omitempty"`
	FileDeviceIDIn           []string `json:"fileDeviceIDIn,omitempty"`
	FileDeviceIDNotIn        []string `json:"fileDeviceIDNotIn,omitempty"`
	FileDeviceIDGT           *string  `json:"fileDeviceIDGT,omitempty"`
	FileDeviceIDGTE          *string  `json:"fileDeviceIDGTE,omitempty"`
	FileDeviceIDLT           *string  `json:"fileDeviceIDLT,omitempty"`
	FileDeviceIDLTE          *string  `json:"fileDeviceIDLTE,omitempty"`
	FileDeviceIDContains     *string  `json:"fileDeviceIDContains,omitempty"`
	FileDeviceIDHasPrefix    *string  `json:"fileDeviceIDHasPrefix,omitempty"`
	FileDeviceIDHasSuffix    *string  `json:"fileDeviceIDHasSuffix,omitempty"`
	FileDeviceIDEqualFold    *string  `json:"fileDeviceIDEqualFold,omitempty"`
	FileDeviceIDContainsFold *string  `json:"fileDeviceIDContainsFold,omitempty"`

	// "file_flags" field predicates.
	FileFlags             *string  `json:"fileFlags,omitempty"`
	FileFlagsNEQ          *string  `json:"fileFlagsNEQ,omitempty"`
	FileFlagsIn           []string `json:"fileFlagsIn,omitempty"`
	FileFlagsNotIn        []string `json:"fileFlagsNotIn,omitempty"`
	FileFlagsGT           *string  `json:"fileFlagsGT,omitempty"`
	FileFlagsGTE          *string  `json:"fileFlagsGTE,omitempty"`
	FileFlagsLT           *string  `json:"fileFlagsLT,omitempty"`
	FileFlagsLTE          *string  `json:"fileFlagsLTE,omitempty"`
	FileFlagsContains     *string  `json:"fileFlagsContains,omitempty"`
	FileFlagsHasPrefix    *string  `json:"fileFlagsHasPrefix,omitempty"`
	FileFlagsHasSuffix    *string  `json:"fileFlagsHasSuffix,omitempty"`
	FileFlagsEqualFold    *string  `json:"fileFlagsEqualFold,omitempty"`
	FileFlagsContainsFold *string  `json:"fileFlagsContainsFold,omitempty"`

	// "file_inode" field predicates.
	FileInode             *string  `json:"fileInode,omitempty"`
	FileInodeNEQ          *string  `json:"fileInodeNEQ,omitempty"`
	FileInodeIn           []string `json:"fileInodeIn,omitempty"`
	FileInodeNotIn        []string `json:"fileInodeNotIn,omitempty"`
	FileInodeGT           *string  `json:"fileInodeGT,omitempty"`
	FileInodeGTE          *string  `json:"fileInodeGTE,omitempty"`
	FileInodeLT           *string  `json:"fileInodeLT,omitempty"`
	FileInodeLTE          *string  `json:"fileInodeLTE,omitempty"`
	FileInodeContains     *string  `json:"fileInodeContains,omitempty"`
	FileInodeHasPrefix    *string  `json:"fileInodeHasPrefix,omitempty"`
	FileInodeHasSuffix    *string  `json:"fileInodeHasSuffix,omitempty"`
	FileInodeEqualFold    *string  `json:"fileInodeEqualFold,omitempty"`
	FileInodeContainsFold *string  `json:"fileInodeContainsFold,omitempty"`

	// "file_system_id" field predicates.
	FileSystemID             *string  `json:"fileSystemID,omitempty"`
	FileSystemIDNEQ          *string  `json:"fileSystemIDNEQ,omitempty"`
	FileSystemIDIn           []string `json:"fileSystemIDIn,omitempty"`
	FileSystemIDNotIn        []string `json:"fileSystemIDNotIn,omitempty"`
	FileSystemIDGT           *string  `json:"fileSystemIDGT,omitempty"`
	FileSystemIDGTE          *string  `json:"fileSystemIDGTE,omitempty"`
	FileSystemIDLT           *string  `json:"fileSystemIDLT,omitempty"`
	FileSystemIDLTE          *string  `json:"fileSystemIDLTE,omitempty"`
	FileSystemIDContains     *string  `json:"fileSystemIDContains,omitempty"`
	FileSystemIDHasPrefix    *string  `json:"fileSystemIDHasPrefix,omitempty"`
	FileSystemIDHasSuffix    *string  `json:"fileSystemIDHasSuffix,omitempty"`
	FileSystemIDEqualFold    *string  `json:"fileSystemIDEqualFold,omitempty"`
	FileSystemIDContainsFold *string  `json:"fileSystemIDContainsFold,omitempty"`

	// "file_type" field predicates.
	FileType             *string  `json:"fileType,omitempty"`
	FileTypeNEQ          *string  `json:"fileTypeNEQ,omitempty"`
	FileTypeIn           []string `json:"fileTypeIn,omitempty"`
	FileTypeNotIn        []string `json:"fileTypeNotIn,omitempty"`
	FileTypeGT           *string  `json:"fileTypeGT,omitempty"`
	FileTypeGTE          *string  `json:"fileTypeGTE,omitempty"`
	FileTypeLT           *string  `json:"fileTypeLT,omitempty"`
	FileTypeLTE          *string  `json:"fileTypeLTE,omitempty"`
	FileTypeContains     *string  `json:"fileTypeContains,omitempty"`
	FileTypeHasPrefix    *string  `json:"fileTypeHasPrefix,omitempty"`
	FileTypeHasSuffix    *string  `json:"fileTypeHasSuffix,omitempty"`
	FileTypeEqualFold    *string  `json:"fileTypeEqualFold,omitempty"`
	FileTypeContainsFold *string  `json:"fileTypeContainsFold,omitempty"`

	// "hard_link_count" field predicates.
	HardLinkCount             *string  `json:"hardLinkCount,omitempty"`
	HardLinkCountNEQ          *string  `json:"hardLinkCountNEQ,omitempty"`
	HardLinkCountIn           []string `json:"hardLinkCountIn,omitempty"`
	HardLinkCountNotIn        []string `json:"hardLinkCountNotIn,omitempty"`
	HardLinkCountGT           *string  `json:"hardLinkCountGT,omitempty"`
	HardLinkCountGTE          *string  `json:"hardLinkCountGTE,omitempty"`
	HardLinkCountLT           *string  `json:"hardLinkCountLT,omitempty"`
	HardLinkCountLTE          *string  `json:"hardLinkCountLTE,omitempty"`
	HardLinkCountContains     *string  `json:"hardLinkCountContains,omitempty"`
	HardLinkCountHasPrefix    *string  `json:"hardLinkCountHasPrefix,omitempty"`
	HardLinkCountHasSuffix    *string  `json:"hardLinkCountHasSuffix,omitempty"`
	HardLinkCountEqualFold    *string  `json:"hardLinkCountEqualFold,omitempty"`
	HardLinkCountContainsFold *string  `json:"hardLinkCountContainsFold,omitempty"`

	// "mtime" field predicates.
	Mtime             *string  `json:"mtime,omitempty"`
	MtimeNEQ          *string  `json:"mtimeNEQ,omitempty"`
	MtimeIn           []string `json:"mtimeIn,omitempty"`
	MtimeNotIn        []string `json:"mtimeNotIn,omitempty"`
	MtimeGT           *string  `json:"mtimeGT,omitempty"`
	MtimeGTE          *string  `json:"mtimeGTE,omitempty"`
	MtimeLT           *string  `json:"mtimeLT,omitempty"`
	MtimeLTE          *string  `json:"mtimeLTE,omitempty"`
	MtimeContains     *string  `json:"mtimeContains,omitempty"`
	MtimeHasPrefix    *string  `json:"mtimeHasPrefix,omitempty"`
	MtimeHasSuffix    *string  `json:"mtimeHasSuffix,omitempty"`
	MtimeEqualFold    *string  `json:"mtimeEqualFold,omitempty"`
	MtimeContainsFold *string  `json:"mtimeContainsFold,omitempty"`

	// "metadata_ctime" field predicates.
	MetadataCtime             *string  `json:"metadataCtime,omitempty"`
	MetadataCtimeNEQ          *string  `json:"metadataCtimeNEQ,omitempty"`
	MetadataCtimeIn           []string `json:"metadataCtimeIn,omitempty"`
	MetadataCtimeNotIn        []string `json:"metadataCtimeNotIn,omitempty"`
	MetadataCtimeGT           *string  `json:"metadataCtimeGT,omitempty"`
	MetadataCtimeGTE          *string  `json:"metadataCtimeGTE,omitempty"`
	MetadataCtimeLT           *string  `json:"metadataCtimeLT,omitempty"`
	MetadataCtimeLTE          *string  `json:"metadataCtimeLTE,omitempty"`
	MetadataCtimeContains     *string  `json:"metadataCtimeContains,omitempty"`
	MetadataCtimeHasPrefix    *string  `json:"metadataCtimeHasPrefix,omitempty"`
	MetadataCtimeHasSuffix    *string  `json:"metadataCtimeHasSuffix,omitempty"`
	MetadataCtimeEqualFold    *string  `json:"metadataCtimeEqualFold,omitempty"`
	MetadataCtimeContainsFold *string  `json:"metadataCtimeContainsFold,omitempty"`

	// "owner_gid" field predicates.
	OwnerGid             *string  `json:"ownerGid,omitempty"`
	OwnerGidNEQ          *string  `json:"ownerGidNEQ,omitempty"`
	OwnerGidIn           []string `json:"ownerGidIn,omitempty"`
	OwnerGidNotIn        []string `json:"ownerGidNotIn,omitempty"`
	OwnerGidGT           *string  `json:"ownerGidGT,omitempty"`
	OwnerGidGTE          *string  `json:"ownerGidGTE,omitempty"`
	OwnerGidLT           *string  `json:"ownerGidLT,omitempty"`
	OwnerGidLTE          *string  `json:"ownerGidLTE,omitempty"`
	OwnerGidContains     *string  `json:"ownerGidContains,omitempty"`
	OwnerGidHasPrefix    *string  `json:"ownerGidHasPrefix,omitempty"`
	OwnerGidHasSuffix    *string  `json:"ownerGidHasSuffix,omitempty"`
	OwnerGidEqualFold    *string  `json:"ownerGidEqualFold,omitempty"`
	OwnerGidContainsFold *string  `json:"ownerGidContainsFold,omitempty"`

	// "owner_uid" field predicates.
	OwnerUID             *string  `json:"ownerUID,omitempty"`
	OwnerUIDNEQ          *string  `json:"ownerUIDNEQ,omitempty"`
	OwnerUIDIn           []string `json:"ownerUIDIn,omitempty"`
	OwnerUIDNotIn        []string `json:"ownerUIDNotIn,omitempty"`
	OwnerUIDGT           *string  `json:"ownerUIDGT,omitempty"`
	OwnerUIDGTE          *string  `json:"ownerUIDGTE,omitempty"`
	OwnerUIDLT           *string  `json:"ownerUIDLT,omitempty"`
	OwnerUIDLTE          *string  `json:"ownerUIDLTE,omitempty"`
	OwnerUIDContains     *string  `json:"ownerUIDContains,omitempty"`
	OwnerUIDHasPrefix    *string  `json:"ownerUIDHasPrefix,omitempty"`
	OwnerUIDHasSuffix    *string  `json:"ownerUIDHasSuffix,omitempty"`
	OwnerUIDEqualFold    *string  `json:"ownerUIDEqualFold,omitempty"`
	OwnerUIDContainsFold *string  `json:"ownerUIDContainsFold,omitempty"`

	// "permissions" field predicates.
	Permissions             *string  `json:"permissions,omitempty"`
	PermissionsNEQ          *string  `json:"permissionsNEQ,omitempty"`
	PermissionsIn           []string `json:"permissionsIn,omitempty"`
	PermissionsNotIn        []string `json:"permissionsNotIn,omitempty"`
	PermissionsGT           *string  `json:"permissionsGT,omitempty"`
	PermissionsGTE          *string  `json:"permissionsGTE,omitempty"`
	PermissionsLT           *string  `json:"permissionsLT,omitempty"`
	PermissionsLTE          *string  `json:"permissionsLTE,omitempty"`
	PermissionsContains     *string  `json:"permissionsContains,omitempty"`
	PermissionsHasPrefix    *string  `json:"permissionsHasPrefix,omitempty"`
	PermissionsHasSuffix    *string  `json:"permissionsHasSuffix,omitempty"`
	PermissionsEqualFold    *string  `json:"permissionsEqualFold,omitempty"`
	PermissionsContainsFold *string  `json:"permissionsContainsFold,omitempty"`

	// "size" field predicates.
	Size             *string  `json:"size,omitempty"`
	SizeNEQ          *string  `json:"sizeNEQ,omitempty"`
	SizeIn           []string `json:"sizeIn,omitempty"`
	SizeNotIn        []string `json:"sizeNotIn,omitempty"`
	SizeGT           *string  `json:"sizeGT,omitempty"`
	SizeGTE          *string  `json:"sizeGTE,omitempty"`
	SizeLT           *string  `json:"sizeLT,omitempty"`
	SizeLTE          *string  `json:"sizeLTE,omitempty"`
	SizeContains     *string  `json:"sizeContains,omitempty"`
	SizeHasPrefix    *string  `json:"sizeHasPrefix,omitempty"`
	SizeHasSuffix    *string  `json:"sizeHasSuffix,omitempty"`
	SizeEqualFold    *string  `json:"sizeEqualFold,omitempty"`
	SizeContainsFold *string  `json:"sizeContainsFold,omitempty"`

	// "mapping" edge predicates.
	HasMapping     *bool                `json:"hasMapping,omitempty"`
	HasMappingWith []*MappingWhereInput `json:"hasMappingWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PosixWhereInput) AddPredicates(predicates ...predicate.Posix) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PosixWhereInput filter on the PosixQuery builder.
func (i *PosixWhereInput) Filter(q *PosixQuery) (*PosixQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPosixWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPosixWhereInput is returned in case the PosixWhereInput is empty.
var ErrEmptyPosixWhereInput = errors.New("ent: empty predicate PosixWhereInput")

// P returns a predicate for filtering posixes.
// An error is returned if the input is empty or invalid.
func (i *PosixWhereInput) P() (predicate.Posix, error) {
	var predicates []predicate.Posix
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, posix.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Posix, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, posix.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Posix, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, posix.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, posix.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, posix.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, posix.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, posix.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, posix.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, posix.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, posix.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, posix.IDLTE(*i.IDLTE))
	}
	if i.Atime != nil {
		predicates = append(predicates, posix.AtimeEQ(*i.Atime))
	}
	if i.AtimeNEQ != nil {
		predicates = append(predicates, posix.AtimeNEQ(*i.AtimeNEQ))
	}
	if len(i.AtimeIn) > 0 {
		predicates = append(predicates, posix.AtimeIn(i.AtimeIn...))
	}
	if len(i.AtimeNotIn) > 0 {
		predicates = append(predicates, posix.AtimeNotIn(i.AtimeNotIn...))
	}
	if i.AtimeGT != nil {
		predicates = append(predicates, posix.AtimeGT(*i.AtimeGT))
	}
	if i.AtimeGTE != nil {
		predicates = append(predicates, posix.AtimeGTE(*i.AtimeGTE))
	}
	if i.AtimeLT != nil {
		predicates = append(predicates, posix.AtimeLT(*i.AtimeLT))
	}
	if i.AtimeLTE != nil {
		predicates = append(predicates, posix.AtimeLTE(*i.AtimeLTE))
	}
	if i.AtimeContains != nil {
		predicates = append(predicates, posix.AtimeContains(*i.AtimeContains))
	}
	if i.AtimeHasPrefix != nil {
		predicates = append(predicates, posix.AtimeHasPrefix(*i.AtimeHasPrefix))
	}
	if i.AtimeHasSuffix != nil {
		predicates = append(predicates, posix.AtimeHasSuffix(*i.AtimeHasSuffix))
	}
	if i.AtimeEqualFold != nil {
		predicates = append(predicates, posix.AtimeEqualFold(*i.AtimeEqualFold))
	}
	if i.AtimeContainsFold != nil {
		predicates = append(predicates, posix.AtimeContainsFold(*i.AtimeContainsFold))
	}
	if i.Ctime != nil {
		predicates = append(predicates, posix.CtimeEQ(*i.Ctime))
	}
	if i.CtimeNEQ != nil {
		predicates = append(predicates, posix.CtimeNEQ(*i.CtimeNEQ))
	}
	if len(i.CtimeIn) > 0 {
		predicates = append(predicates, posix.CtimeIn(i.CtimeIn...))
	}
	if len(i.CtimeNotIn) > 0 {
		predicates = append(predicates, posix.CtimeNotIn(i.CtimeNotIn...))
	}
	if i.CtimeGT != nil {
		predicates = append(predicates, posix.CtimeGT(*i.CtimeGT))
	}
	if i.CtimeGTE != nil {
		predicates = append(predicates, posix.CtimeGTE(*i.CtimeGTE))
	}
	if i.CtimeLT != nil {
		predicates = append(predicates, posix.CtimeLT(*i.CtimeLT))
	}
	if i.CtimeLTE != nil {
		predicates = append(predicates, posix.CtimeLTE(*i.CtimeLTE))
	}
	if i.CtimeContains != nil {
		predicates = append(predicates, posix.CtimeContains(*i.CtimeContains))
	}
	if i.CtimeHasPrefix != nil {
		predicates = append(predicates, posix.CtimeHasPrefix(*i.CtimeHasPrefix))
	}
	if i.CtimeHasSuffix != nil {
		predicates = append(predicates, posix.CtimeHasSuffix(*i.CtimeHasSuffix))
	}
	if i.CtimeEqualFold != nil {
		predicates = append(predicates, posix.CtimeEqualFold(*i.CtimeEqualFold))
	}
	if i.CtimeContainsFold != nil {
		predicates = append(predicates, posix.CtimeContainsFold(*i.CtimeContainsFold))
	}
	if i.CreationTime != nil {
		predicates = append(predicates, posix.CreationTimeEQ(*i.CreationTime))
	}
	if i.CreationTimeNEQ != nil {
		predicates = append(predicates, posix.CreationTimeNEQ(*i.CreationTimeNEQ))
	}
	if len(i.CreationTimeIn) > 0 {
		predicates = append(predicates, posix.CreationTimeIn(i.CreationTimeIn...))
	}
	if len(i.CreationTimeNotIn) > 0 {
		predicates = append(predicates, posix.CreationTimeNotIn(i.CreationTimeNotIn...))
	}
	if i.CreationTimeGT != nil {
		predicates = append(predicates, posix.CreationTimeGT(*i.CreationTimeGT))
	}
	if i.CreationTimeGTE != nil {
		predicates = append(predicates, posix.CreationTimeGTE(*i.CreationTimeGTE))
	}
	if i.CreationTimeLT != nil {
		predicates = append(predicates, posix.CreationTimeLT(*i.CreationTimeLT))
	}
	if i.CreationTimeLTE != nil {
		predicates = append(predicates, posix.CreationTimeLTE(*i.CreationTimeLTE))
	}
	if i.CreationTimeContains != nil {
		predicates = append(predicates, posix.CreationTimeContains(*i.CreationTimeContains))
	}
	if i.CreationTimeHasPrefix != nil {
		predicates = append(predicates, posix.CreationTimeHasPrefix(*i.CreationTimeHasPrefix))
	}
	if i.CreationTimeHasSuffix != nil {
		predicates = append(predicates, posix.CreationTimeHasSuffix(*i.CreationTimeHasSuffix))
	}
	if i.CreationTimeEqualFold != nil {
		predicates = append(predicates, posix.CreationTimeEqualFold(*i.CreationTimeEqualFold))
	}
	if i.CreationTimeContainsFold != nil {
		predicates = append(predicates, posix.CreationTimeContainsFold(*i.CreationTimeContainsFold))
	}
	if i.ExtendedAttributes != nil {
		predicates = append(predicates, posix.ExtendedAttributesEQ(*i.ExtendedAttributes))
	}
	if i.ExtendedAttributesNEQ != nil {
		predicates = append(predicates, posix.ExtendedAttributesNEQ(*i.ExtendedAttributesNEQ))
	}
	if len(i.ExtendedAttributesIn) > 0 {
		predicates = append(predicates, posix.ExtendedAttributesIn(i.ExtendedAttributesIn...))
	}
	if len(i.ExtendedAttributesNotIn) > 0 {
		predicates = append(predicates, posix.ExtendedAttributesNotIn(i.ExtendedAttributesNotIn...))
	}
	if i.ExtendedAttributesGT != nil {
		predicates = append(predicates, posix.ExtendedAttributesGT(*i.ExtendedAttributesGT))
	}
	if i.ExtendedAttributesGTE != nil {
		predicates = append(predicates, posix.ExtendedAttributesGTE(*i.ExtendedAttributesGTE))
	}
	if i.ExtendedAttributesLT != nil {
		predicates = append(predicates, posix.ExtendedAttributesLT(*i.ExtendedAttributesLT))
	}
	if i.ExtendedAttributesLTE != nil {
		predicates = append(predicates, posix.ExtendedAttributesLTE(*i.ExtendedAttributesLTE))
	}
	if i.ExtendedAttributesContains != nil {
		predicates = append(predicates, posix.ExtendedAttributesContains(*i.ExtendedAttributesContains))
	}
	if i.ExtendedAttributesHasPrefix != nil {
		predicates = append(predicates, posix.ExtendedAttributesHasPrefix(*i.ExtendedAttributesHasPrefix))
	}
	if i.ExtendedAttributesHasSuffix != nil {
		predicates = append(predicates, posix.ExtendedAttributesHasSuffix(*i.ExtendedAttributesHasSuffix))
	}
	if i.ExtendedAttributesEqualFold != nil {
		predicates = append(predicates, posix.ExtendedAttributesEqualFold(*i.ExtendedAttributesEqualFold))
	}
	if i.ExtendedAttributesContainsFold != nil {
		predicates = append(predicates, posix.ExtendedAttributesContainsFold(*i.ExtendedAttributesContainsFold))
	}
	if i.FileDeviceID != nil {
		predicates = append(predicates, posix.FileDeviceIDEQ(*i.FileDeviceID))
	}
	if i.FileDeviceIDNEQ != nil {
		predicates = append(predicates, posix.FileDeviceIDNEQ(*i.FileDeviceIDNEQ))
	}
	if len(i.FileDeviceIDIn) > 0 {
		predicates = append(predicates, posix.FileDeviceIDIn(i.FileDeviceIDIn...))
	}
	if len(i.FileDeviceIDNotIn) > 0 {
		predicates = append(predicates, posix.FileDeviceIDNotIn(i.FileDeviceIDNotIn...))
	}
	if i.FileDeviceIDGT != nil {
		predicates = append(predicates, posix.FileDeviceIDGT(*i.FileDeviceIDGT))
	}
	if i.FileDeviceIDGTE != nil {
		predicates = append(predicates, posix.FileDeviceIDGTE(*i.FileDeviceIDGTE))
	}
	if i.FileDeviceIDLT != nil {
		predicates = append(predicates, posix.FileDeviceIDLT(*i.FileDeviceIDLT))
	}
	if i.FileDeviceIDLTE != nil {
		predicates = append(predicates, posix.FileDeviceIDLTE(*i.FileDeviceIDLTE))
	}
	if i.FileDeviceIDContains != nil {
		predicates = append(predicates, posix.FileDeviceIDContains(*i.FileDeviceIDContains))
	}
	if i.FileDeviceIDHasPrefix != nil {
		predicates = append(predicates, posix.FileDeviceIDHasPrefix(*i.FileDeviceIDHasPrefix))
	}
	if i.FileDeviceIDHasSuffix != nil {
		predicates = append(predicates, posix.FileDeviceIDHasSuffix(*i.FileDeviceIDHasSuffix))
	}
	if i.FileDeviceIDEqualFold != nil {
		predicates = append(predicates, posix.FileDeviceIDEqualFold(*i.FileDeviceIDEqualFold))
	}
	if i.FileDeviceIDContainsFold != nil {
		predicates = append(predicates, posix.FileDeviceIDContainsFold(*i.FileDeviceIDContainsFold))
	}
	if i.FileFlags != nil {
		predicates = append(predicates, posix.FileFlagsEQ(*i.FileFlags))
	}
	if i.FileFlagsNEQ != nil {
		predicates = append(predicates, posix.FileFlagsNEQ(*i.FileFlagsNEQ))
	}
	if len(i.FileFlagsIn) > 0 {
		predicates = append(predicates, posix.FileFlagsIn(i.FileFlagsIn...))
	}
	if len(i.FileFlagsNotIn) > 0 {
		predicates = append(predicates, posix.FileFlagsNotIn(i.FileFlagsNotIn...))
	}
	if i.FileFlagsGT != nil {
		predicates = append(predicates, posix.FileFlagsGT(*i.FileFlagsGT))
	}
	if i.FileFlagsGTE != nil {
		predicates = append(predicates, posix.FileFlagsGTE(*i.FileFlagsGTE))
	}
	if i.FileFlagsLT != nil {
		predicates = append(predicates, posix.FileFlagsLT(*i.FileFlagsLT))
	}
	if i.FileFlagsLTE != nil {
		predicates = append(predicates, posix.FileFlagsLTE(*i.FileFlagsLTE))
	}
	if i.FileFlagsContains != nil {
		predicates = append(predicates, posix.FileFlagsContains(*i.FileFlagsContains))
	}
	if i.FileFlagsHasPrefix != nil {
		predicates = append(predicates, posix.FileFlagsHasPrefix(*i.FileFlagsHasPrefix))
	}
	if i.FileFlagsHasSuffix != nil {
		predicates = append(predicates, posix.FileFlagsHasSuffix(*i.FileFlagsHasSuffix))
	}
	if i.FileFlagsEqualFold != nil {
		predicates = append(predicates, posix.FileFlagsEqualFold(*i.FileFlagsEqualFold))
	}
	if i.FileFlagsContainsFold != nil {
		predicates = append(predicates, posix.FileFlagsContainsFold(*i.FileFlagsContainsFold))
	}
	if i.FileInode != nil {
		predicates = append(predicates, posix.FileInodeEQ(*i.FileInode))
	}
	if i.FileInodeNEQ != nil {
		predicates = append(predicates, posix.FileInodeNEQ(*i.FileInodeNEQ))
	}
	if len(i.FileInodeIn) > 0 {
		predicates = append(predicates, posix.FileInodeIn(i.FileInodeIn...))
	}
	if len(i.FileInodeNotIn) > 0 {
		predicates = append(predicates, posix.FileInodeNotIn(i.FileInodeNotIn...))
	}
	if i.FileInodeGT != nil {
		predicates = append(predicates, posix.FileInodeGT(*i.FileInodeGT))
	}
	if i.FileInodeGTE != nil {
		predicates = append(predicates, posix.FileInodeGTE(*i.FileInodeGTE))
	}
	if i.FileInodeLT != nil {
		predicates = append(predicates, posix.FileInodeLT(*i.FileInodeLT))
	}
	if i.FileInodeLTE != nil {
		predicates = append(predicates, posix.FileInodeLTE(*i.FileInodeLTE))
	}
	if i.FileInodeContains != nil {
		predicates = append(predicates, posix.FileInodeContains(*i.FileInodeContains))
	}
	if i.FileInodeHasPrefix != nil {
		predicates = append(predicates, posix.FileInodeHasPrefix(*i.FileInodeHasPrefix))
	}
	if i.FileInodeHasSuffix != nil {
		predicates = append(predicates, posix.FileInodeHasSuffix(*i.FileInodeHasSuffix))
	}
	if i.FileInodeEqualFold != nil {
		predicates = append(predicates, posix.FileInodeEqualFold(*i.FileInodeEqualFold))
	}
	if i.FileInodeContainsFold != nil {
		predicates = append(predicates, posix.FileInodeContainsFold(*i.FileInodeContainsFold))
	}
	if i.FileSystemID != nil {
		predicates = append(predicates, posix.FileSystemIDEQ(*i.FileSystemID))
	}
	if i.FileSystemIDNEQ != nil {
		predicates = append(predicates, posix.FileSystemIDNEQ(*i.FileSystemIDNEQ))
	}
	if len(i.FileSystemIDIn) > 0 {
		predicates = append(predicates, posix.FileSystemIDIn(i.FileSystemIDIn...))
	}
	if len(i.FileSystemIDNotIn) > 0 {
		predicates = append(predicates, posix.FileSystemIDNotIn(i.FileSystemIDNotIn...))
	}
	if i.FileSystemIDGT != nil {
		predicates = append(predicates, posix.FileSystemIDGT(*i.FileSystemIDGT))
	}
	if i.FileSystemIDGTE != nil {
		predicates = append(predicates, posix.FileSystemIDGTE(*i.FileSystemIDGTE))
	}
	if i.FileSystemIDLT != nil {
		predicates = append(predicates, posix.FileSystemIDLT(*i.FileSystemIDLT))
	}
	if i.FileSystemIDLTE != nil {
		predicates = append(predicates, posix.FileSystemIDLTE(*i.FileSystemIDLTE))
	}
	if i.FileSystemIDContains != nil {
		predicates = append(predicates, posix.FileSystemIDContains(*i.FileSystemIDContains))
	}
	if i.FileSystemIDHasPrefix != nil {
		predicates = append(predicates, posix.FileSystemIDHasPrefix(*i.FileSystemIDHasPrefix))
	}
	if i.FileSystemIDHasSuffix != nil {
		predicates = append(predicates, posix.FileSystemIDHasSuffix(*i.FileSystemIDHasSuffix))
	}
	if i.FileSystemIDEqualFold != nil {
		predicates = append(predicates, posix.FileSystemIDEqualFold(*i.FileSystemIDEqualFold))
	}
	if i.FileSystemIDContainsFold != nil {
		predicates = append(predicates, posix.FileSystemIDContainsFold(*i.FileSystemIDContainsFold))
	}
	if i.FileType != nil {
		predicates = append(predicates, posix.FileTypeEQ(*i.FileType))
	}
	if i.FileTypeNEQ != nil {
		predicates = append(predicates, posix.FileTypeNEQ(*i.FileTypeNEQ))
	}
	if len(i.FileTypeIn) > 0 {
		predicates = append(predicates, posix.FileTypeIn(i.FileTypeIn...))
	}
	if len(i.FileTypeNotIn) > 0 {
		predicates = append(predicates, posix.FileTypeNotIn(i.FileTypeNotIn...))
	}
	if i.FileTypeGT != nil {
		predicates = append(predicates, posix.FileTypeGT(*i.FileTypeGT))
	}
	if i.FileTypeGTE != nil {
		predicates = append(predicates, posix.FileTypeGTE(*i.FileTypeGTE))
	}
	if i.FileTypeLT != nil {
		predicates = append(predicates, posix.FileTypeLT(*i.FileTypeLT))
	}
	if i.FileTypeLTE != nil {
		predicates = append(predicates, posix.FileTypeLTE(*i.FileTypeLTE))
	}
	if i.FileTypeContains != nil {
		predicates = append(predicates, posix.FileTypeContains(*i.FileTypeContains))
	}
	if i.FileTypeHasPrefix != nil {
		predicates = append(predicates, posix.FileTypeHasPrefix(*i.FileTypeHasPrefix))
	}
	if i.FileTypeHasSuffix != nil {
		predicates = append(predicates, posix.FileTypeHasSuffix(*i.FileTypeHasSuffix))
	}
	if i.FileTypeEqualFold != nil {
		predicates = append(predicates, posix.FileTypeEqualFold(*i.FileTypeEqualFold))
	}
	if i.FileTypeContainsFold != nil {
		predicates = append(predicates, posix.FileTypeContainsFold(*i.FileTypeContainsFold))
	}
	if i.HardLinkCount != nil {
		predicates = append(predicates, posix.HardLinkCountEQ(*i.HardLinkCount))
	}
	if i.HardLinkCountNEQ != nil {
		predicates = append(predicates, posix.HardLinkCountNEQ(*i.HardLinkCountNEQ))
	}
	if len(i.HardLinkCountIn) > 0 {
		predicates = append(predicates, posix.HardLinkCountIn(i.HardLinkCountIn...))
	}
	if len(i.HardLinkCountNotIn) > 0 {
		predicates = append(predicates, posix.HardLinkCountNotIn(i.HardLinkCountNotIn...))
	}
	if i.HardLinkCountGT != nil {
		predicates = append(predicates, posix.HardLinkCountGT(*i.HardLinkCountGT))
	}
	if i.HardLinkCountGTE != nil {
		predicates = append(predicates, posix.HardLinkCountGTE(*i.HardLinkCountGTE))
	}
	if i.HardLinkCountLT != nil {
		predicates = append(predicates, posix.HardLinkCountLT(*i.HardLinkCountLT))
	}
	if i.HardLinkCountLTE != nil {
		predicates = append(predicates, posix.HardLinkCountLTE(*i.HardLinkCountLTE))
	}
	if i.HardLinkCountContains != nil {
		predicates = append(predicates, posix.HardLinkCountContains(*i.HardLinkCountContains))
	}
	if i.HardLinkCountHasPrefix != nil {
		predicates = append(predicates, posix.HardLinkCountHasPrefix(*i.HardLinkCountHasPrefix))
	}
	if i.HardLinkCountHasSuffix != nil {
		predicates = append(predicates, posix.HardLinkCountHasSuffix(*i.HardLinkCountHasSuffix))
	}
	if i.HardLinkCountEqualFold != nil {
		predicates = append(predicates, posix.HardLinkCountEqualFold(*i.HardLinkCountEqualFold))
	}
	if i.HardLinkCountContainsFold != nil {
		predicates = append(predicates, posix.HardLinkCountContainsFold(*i.HardLinkCountContainsFold))
	}
	if i.Mtime != nil {
		predicates = append(predicates, posix.MtimeEQ(*i.Mtime))
	}
	if i.MtimeNEQ != nil {
		predicates = append(predicates, posix.MtimeNEQ(*i.MtimeNEQ))
	}
	if len(i.MtimeIn) > 0 {
		predicates = append(predicates, posix.MtimeIn(i.MtimeIn...))
	}
	if len(i.MtimeNotIn) > 0 {
		predicates = append(predicates, posix.MtimeNotIn(i.MtimeNotIn...))
	}
	if i.MtimeGT != nil {
		predicates = append(predicates, posix.MtimeGT(*i.MtimeGT))
	}
	if i.MtimeGTE != nil {
		predicates = append(predicates, posix.MtimeGTE(*i.MtimeGTE))
	}
	if i.MtimeLT != nil {
		predicates = append(predicates, posix.MtimeLT(*i.MtimeLT))
	}
	if i.MtimeLTE != nil {
		predicates = append(predicates, posix.MtimeLTE(*i.MtimeLTE))
	}
	if i.MtimeContains != nil {
		predicates = append(predicates, posix.MtimeContains(*i.MtimeContains))
	}
	if i.MtimeHasPrefix != nil {
		predicates = append(predicates, posix.MtimeHasPrefix(*i.MtimeHasPrefix))
	}
	if i.MtimeHasSuffix != nil {
		predicates = append(predicates, posix.MtimeHasSuffix(*i.MtimeHasSuffix))
	}
	if i.MtimeEqualFold != nil {
		predicates = append(predicates, posix.MtimeEqualFold(*i.MtimeEqualFold))
	}
	if i.MtimeContainsFold != nil {
		predicates = append(predicates, posix.MtimeContainsFold(*i.MtimeContainsFold))
	}
	if i.MetadataCtime != nil {
		predicates = append(predicates, posix.MetadataCtimeEQ(*i.MetadataCtime))
	}
	if i.MetadataCtimeNEQ != nil {
		predicates = append(predicates, posix.MetadataCtimeNEQ(*i.MetadataCtimeNEQ))
	}
	if len(i.MetadataCtimeIn) > 0 {
		predicates = append(predicates, posix.MetadataCtimeIn(i.MetadataCtimeIn...))
	}
	if len(i.MetadataCtimeNotIn) > 0 {
		predicates = append(predicates, posix.MetadataCtimeNotIn(i.MetadataCtimeNotIn...))
	}
	if i.MetadataCtimeGT != nil {
		predicates = append(predicates, posix.MetadataCtimeGT(*i.MetadataCtimeGT))
	}
	if i.MetadataCtimeGTE != nil {
		predicates = append(predicates, posix.MetadataCtimeGTE(*i.MetadataCtimeGTE))
	}
	if i.MetadataCtimeLT != nil {
		predicates = append(predicates, posix.MetadataCtimeLT(*i.MetadataCtimeLT))
	}
	if i.MetadataCtimeLTE != nil {
		predicates = append(predicates, posix.MetadataCtimeLTE(*i.MetadataCtimeLTE))
	}
	if i.MetadataCtimeContains != nil {
		predicates = append(predicates, posix.MetadataCtimeContains(*i.MetadataCtimeContains))
	}
	if i.MetadataCtimeHasPrefix != nil {
		predicates = append(predicates, posix.MetadataCtimeHasPrefix(*i.MetadataCtimeHasPrefix))
	}
	if i.MetadataCtimeHasSuffix != nil {
		predicates = append(predicates, posix.MetadataCtimeHasSuffix(*i.MetadataCtimeHasSuffix))
	}
	if i.MetadataCtimeEqualFold != nil {
		predicates = append(predicates, posix.MetadataCtimeEqualFold(*i.MetadataCtimeEqualFold))
	}
	if i.MetadataCtimeContainsFold != nil {
		predicates = append(predicates, posix.MetadataCtimeContainsFold(*i.MetadataCtimeContainsFold))
	}
	if i.OwnerGid != nil {
		predicates = append(predicates, posix.OwnerGidEQ(*i.OwnerGid))
	}
	if i.OwnerGidNEQ != nil {
		predicates = append(predicates, posix.OwnerGidNEQ(*i.OwnerGidNEQ))
	}
	if len(i.OwnerGidIn) > 0 {
		predicates = append(predicates, posix.OwnerGidIn(i.OwnerGidIn...))
	}
	if len(i.OwnerGidNotIn) > 0 {
		predicates = append(predicates, posix.OwnerGidNotIn(i.OwnerGidNotIn...))
	}
	if i.OwnerGidGT != nil {
		predicates = append(predicates, posix.OwnerGidGT(*i.OwnerGidGT))
	}
	if i.OwnerGidGTE != nil {
		predicates = append(predicates, posix.OwnerGidGTE(*i.OwnerGidGTE))
	}
	if i.OwnerGidLT != nil {
		predicates = append(predicates, posix.OwnerGidLT(*i.OwnerGidLT))
	}
	if i.OwnerGidLTE != nil {
		predicates = append(predicates, posix.OwnerGidLTE(*i.OwnerGidLTE))
	}
	if i.OwnerGidContains != nil {
		predicates = append(predicates, posix.OwnerGidContains(*i.OwnerGidContains))
	}
	if i.OwnerGidHasPrefix != nil {
		predicates = append(predicates, posix.OwnerGidHasPrefix(*i.OwnerGidHasPrefix))
	}
	if i.OwnerGidHasSuffix != nil {
		predicates = append(predicates, posix.OwnerGidHasSuffix(*i.OwnerGidHasSuffix))
	}
	if i.OwnerGidEqualFold != nil {
		predicates = append(predicates, posix.OwnerGidEqualFold(*i.OwnerGidEqualFold))
	}
	if i.OwnerGidContainsFold != nil {
		predicates = append(predicates, posix.OwnerGidContainsFold(*i.OwnerGidContainsFold))
	}
	if i.OwnerUID != nil {
		predicates = append(predicates, posix.OwnerUIDEQ(*i.OwnerUID))
	}
	if i.OwnerUIDNEQ != nil {
		predicates = append(predicates, posix.OwnerUIDNEQ(*i.OwnerUIDNEQ))
	}
	if len(i.OwnerUIDIn) > 0 {
		predicates = append(predicates, posix.OwnerUIDIn(i.OwnerUIDIn...))
	}
	if len(i.OwnerUIDNotIn) > 0 {
		predicates = append(predicates, posix.OwnerUIDNotIn(i.OwnerUIDNotIn...))
	}
	if i.OwnerUIDGT != nil {
		predicates = append(predicates, posix.OwnerUIDGT(*i.OwnerUIDGT))
	}
	if i.OwnerUIDGTE != nil {
		predicates = append(predicates, posix.OwnerUIDGTE(*i.OwnerUIDGTE))
	}
	if i.OwnerUIDLT != nil {
		predicates = append(predicates, posix.OwnerUIDLT(*i.OwnerUIDLT))
	}
	if i.OwnerUIDLTE != nil {
		predicates = append(predicates, posix.OwnerUIDLTE(*i.OwnerUIDLTE))
	}
	if i.OwnerUIDContains != nil {
		predicates = append(predicates, posix.OwnerUIDContains(*i.OwnerUIDContains))
	}
	if i.OwnerUIDHasPrefix != nil {
		predicates = append(predicates, posix.OwnerUIDHasPrefix(*i.OwnerUIDHasPrefix))
	}
	if i.OwnerUIDHasSuffix != nil {
		predicates = append(predicates, posix.OwnerUIDHasSuffix(*i.OwnerUIDHasSuffix))
	}
	if i.OwnerUIDEqualFold != nil {
		predicates = append(predicates, posix.OwnerUIDEqualFold(*i.OwnerUIDEqualFold))
	}
	if i.OwnerUIDContainsFold != nil {
		predicates = append(predicates, posix.OwnerUIDContainsFold(*i.OwnerUIDContainsFold))
	}
	if i.Permissions != nil {
		predicates = append(predicates, posix.PermissionsEQ(*i.Permissions))
	}
	if i.PermissionsNEQ != nil {
		predicates = append(predicates, posix.PermissionsNEQ(*i.PermissionsNEQ))
	}
	if len(i.PermissionsIn) > 0 {
		predicates = append(predicates, posix.PermissionsIn(i.PermissionsIn...))
	}
	if len(i.PermissionsNotIn) > 0 {
		predicates = append(predicates, posix.PermissionsNotIn(i.PermissionsNotIn...))
	}
	if i.PermissionsGT != nil {
		predicates = append(predicates, posix.PermissionsGT(*i.PermissionsGT))
	}
	if i.PermissionsGTE != nil {
		predicates = append(predicates, posix.PermissionsGTE(*i.PermissionsGTE))
	}
	if i.PermissionsLT != nil {
		predicates = append(predicates, posix.PermissionsLT(*i.PermissionsLT))
	}
	if i.PermissionsLTE != nil {
		predicates = append(predicates, posix.PermissionsLTE(*i.PermissionsLTE))
	}
	if i.PermissionsContains != nil {
		predicates = append(predicates, posix.PermissionsContains(*i.PermissionsContains))
	}
	if i.PermissionsHasPrefix != nil {
		predicates = append(predicates, posix.PermissionsHasPrefix(*i.PermissionsHasPrefix))
	}
	if i.PermissionsHasSuffix != nil {
		predicates = append(predicates, posix.PermissionsHasSuffix(*i.PermissionsHasSuffix))
	}
	if i.PermissionsEqualFold != nil {
		predicates = append(predicates, posix.PermissionsEqualFold(*i.PermissionsEqualFold))
	}
	if i.PermissionsContainsFold != nil {
		predicates = append(predicates, posix.PermissionsContainsFold(*i.PermissionsContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, posix.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, posix.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, posix.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, posix.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, posix.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, posix.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, posix.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, posix.SizeLTE(*i.SizeLTE))
	}
	if i.SizeContains != nil {
		predicates = append(predicates, posix.SizeContains(*i.SizeContains))
	}
	if i.SizeHasPrefix != nil {
		predicates = append(predicates, posix.SizeHasPrefix(*i.SizeHasPrefix))
	}
	if i.SizeHasSuffix != nil {
		predicates = append(predicates, posix.SizeHasSuffix(*i.SizeHasSuffix))
	}
	if i.SizeEqualFold != nil {
		predicates = append(predicates, posix.SizeEqualFold(*i.SizeEqualFold))
	}
	if i.SizeContainsFold != nil {
		predicates = append(predicates, posix.SizeContainsFold(*i.SizeContainsFold))
	}

	if i.HasMapping != nil {
		p := posix.HasMapping()
		if !*i.HasMapping {
			p = posix.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMappingWith) > 0 {
		with := make([]predicate.Mapping, 0, len(i.HasMappingWith))
		for _, w := range i.HasMappingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMappingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, posix.HasMappingWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPosixWhereInput
	case 1:
		return predicates[0], nil
	default:
		return posix.And(predicates...), nil
	}
}

// SignatureWhereInput represents a where input for filtering Signature queries.
type SignatureWhereInput struct {
	Predicates []predicate.Signature  `json:"-"`
	Not        *SignatureWhereInput   `json:"not,omitempty"`
	Or         []*SignatureWhereInput `json:"or,omitempty"`
	And        []*SignatureWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "key_id" field predicates.
	KeyID             *string  `json:"keyID,omitempty"`
	KeyIDNEQ          *string  `json:"keyIDNEQ,omitempty"`
	KeyIDIn           []string `json:"keyIDIn,omitempty"`
	KeyIDNotIn        []string `json:"keyIDNotIn,omitempty"`
	KeyIDGT           *string  `json:"keyIDGT,omitempty"`
	KeyIDGTE          *string  `json:"keyIDGTE,omitempty"`
	KeyIDLT           *string  `json:"keyIDLT,omitempty"`
	KeyIDLTE          *string  `json:"keyIDLTE,omitempty"`
	KeyIDContains     *string  `json:"keyIDContains,omitempty"`
	KeyIDHasPrefix    *string  `json:"keyIDHasPrefix,omitempty"`
	KeyIDHasSuffix    *string  `json:"keyIDHasSuffix,omitempty"`
	KeyIDEqualFold    *string  `json:"keyIDEqualFold,omitempty"`
	KeyIDContainsFold *string  `json:"keyIDContainsFold,omitempty"`

	// "signature" field predicates.
	Signature             *string  `json:"signature,omitempty"`
	SignatureNEQ          *string  `json:"signatureNEQ,omitempty"`
	SignatureIn           []string `json:"signatureIn,omitempty"`
	SignatureNotIn        []string `json:"signatureNotIn,omitempty"`
	SignatureGT           *string  `json:"signatureGT,omitempty"`
	SignatureGTE          *string  `json:"signatureGTE,omitempty"`
	SignatureLT           *string  `json:"signatureLT,omitempty"`
	SignatureLTE          *string  `json:"signatureLTE,omitempty"`
	SignatureContains     *string  `json:"signatureContains,omitempty"`
	SignatureHasPrefix    *string  `json:"signatureHasPrefix,omitempty"`
	SignatureHasSuffix    *string  `json:"signatureHasSuffix,omitempty"`
	SignatureEqualFold    *string  `json:"signatureEqualFold,omitempty"`
	SignatureContainsFold *string  `json:"signatureContainsFold,omitempty"`

	// "dsse" edge predicates.
	HasDsse     *bool             `json:"hasDsse,omitempty"`
	HasDsseWith []*DsseWhereInput `json:"hasDsseWith,omitempty"`

	// "timestamps" edge predicates.
	HasTimestamps     *bool                  `json:"hasTimestamps,omitempty"`
	HasTimestampsWith []*TimestampWhereInput `json:"hasTimestampsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SignatureWhereInput) AddPredicates(predicates ...predicate.Signature) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SignatureWhereInput filter on the SignatureQuery builder.
func (i *SignatureWhereInput) Filter(q *SignatureQuery) (*SignatureQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySignatureWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySignatureWhereInput is returned in case the SignatureWhereInput is empty.
var ErrEmptySignatureWhereInput = errors.New("ent: empty predicate SignatureWhereInput")

// P returns a predicate for filtering signatures.
// An error is returned if the input is empty or invalid.
func (i *SignatureWhereInput) P() (predicate.Signature, error) {
	var predicates []predicate.Signature
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, signature.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Signature, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, signature.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Signature, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, signature.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, signature.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, signature.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, signature.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, signature.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, signature.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, signature.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, signature.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, signature.IDLTE(*i.IDLTE))
	}
	if i.KeyID != nil {
		predicates = append(predicates, signature.KeyIDEQ(*i.KeyID))
	}
	if i.KeyIDNEQ != nil {
		predicates = append(predicates, signature.KeyIDNEQ(*i.KeyIDNEQ))
	}
	if len(i.KeyIDIn) > 0 {
		predicates = append(predicates, signature.KeyIDIn(i.KeyIDIn...))
	}
	if len(i.KeyIDNotIn) > 0 {
		predicates = append(predicates, signature.KeyIDNotIn(i.KeyIDNotIn...))
	}
	if i.KeyIDGT != nil {
		predicates = append(predicates, signature.KeyIDGT(*i.KeyIDGT))
	}
	if i.KeyIDGTE != nil {
		predicates = append(predicates, signature.KeyIDGTE(*i.KeyIDGTE))
	}
	if i.KeyIDLT != nil {
		predicates = append(predicates, signature.KeyIDLT(*i.KeyIDLT))
	}
	if i.KeyIDLTE != nil {
		predicates = append(predicates, signature.KeyIDLTE(*i.KeyIDLTE))
	}
	if i.KeyIDContains != nil {
		predicates = append(predicates, signature.KeyIDContains(*i.KeyIDContains))
	}
	if i.KeyIDHasPrefix != nil {
		predicates = append(predicates, signature.KeyIDHasPrefix(*i.KeyIDHasPrefix))
	}
	if i.KeyIDHasSuffix != nil {
		predicates = append(predicates, signature.KeyIDHasSuffix(*i.KeyIDHasSuffix))
	}
	if i.KeyIDEqualFold != nil {
		predicates = append(predicates, signature.KeyIDEqualFold(*i.KeyIDEqualFold))
	}
	if i.KeyIDContainsFold != nil {
		predicates = append(predicates, signature.KeyIDContainsFold(*i.KeyIDContainsFold))
	}
	if i.Signature != nil {
		predicates = append(predicates, signature.SignatureEQ(*i.Signature))
	}
	if i.SignatureNEQ != nil {
		predicates = append(predicates, signature.SignatureNEQ(*i.SignatureNEQ))
	}
	if len(i.SignatureIn) > 0 {
		predicates = append(predicates, signature.SignatureIn(i.SignatureIn...))
	}
	if len(i.SignatureNotIn) > 0 {
		predicates = append(predicates, signature.SignatureNotIn(i.SignatureNotIn...))
	}
	if i.SignatureGT != nil {
		predicates = append(predicates, signature.SignatureGT(*i.SignatureGT))
	}
	if i.SignatureGTE != nil {
		predicates = append(predicates, signature.SignatureGTE(*i.SignatureGTE))
	}
	if i.SignatureLT != nil {
		predicates = append(predicates, signature.SignatureLT(*i.SignatureLT))
	}
	if i.SignatureLTE != nil {
		predicates = append(predicates, signature.SignatureLTE(*i.SignatureLTE))
	}
	if i.SignatureContains != nil {
		predicates = append(predicates, signature.SignatureContains(*i.SignatureContains))
	}
	if i.SignatureHasPrefix != nil {
		predicates = append(predicates, signature.SignatureHasPrefix(*i.SignatureHasPrefix))
	}
	if i.SignatureHasSuffix != nil {
		predicates = append(predicates, signature.SignatureHasSuffix(*i.SignatureHasSuffix))
	}
	if i.SignatureEqualFold != nil {
		predicates = append(predicates, signature.SignatureEqualFold(*i.SignatureEqualFold))
	}
	if i.SignatureContainsFold != nil {
		predicates = append(predicates, signature.SignatureContainsFold(*i.SignatureContainsFold))
	}

	if i.HasDsse != nil {
		p := signature.HasDsse()
		if !*i.HasDsse {
			p = signature.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDsseWith) > 0 {
		with := make([]predicate.Dsse, 0, len(i.HasDsseWith))
		for _, w := range i.HasDsseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDsseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, signature.HasDsseWith(with...))
	}
	if i.HasTimestamps != nil {
		p := signature.HasTimestamps()
		if !*i.HasTimestamps {
			p = signature.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTimestampsWith) > 0 {
		with := make([]predicate.Timestamp, 0, len(i.HasTimestampsWith))
		for _, w := range i.HasTimestampsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTimestampsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, signature.HasTimestampsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySignatureWhereInput
	case 1:
		return predicates[0], nil
	default:
		return signature.And(predicates...), nil
	}
}

// StatementWhereInput represents a where input for filtering Statement queries.
type StatementWhereInput struct {
	Predicates []predicate.Statement  `json:"-"`
	Not        *StatementWhereInput   `json:"not,omitempty"`
	Or         []*StatementWhereInput `json:"or,omitempty"`
	And        []*StatementWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "predicate" field predicates.
	Predicate             *string  `json:"predicate,omitempty"`
	PredicateNEQ          *string  `json:"predicateNEQ,omitempty"`
	PredicateIn           []string `json:"predicateIn,omitempty"`
	PredicateNotIn        []string `json:"predicateNotIn,omitempty"`
	PredicateGT           *string  `json:"predicateGT,omitempty"`
	PredicateGTE          *string  `json:"predicateGTE,omitempty"`
	PredicateLT           *string  `json:"predicateLT,omitempty"`
	PredicateLTE          *string  `json:"predicateLTE,omitempty"`
	PredicateContains     *string  `json:"predicateContains,omitempty"`
	PredicateHasPrefix    *string  `json:"predicateHasPrefix,omitempty"`
	PredicateHasSuffix    *string  `json:"predicateHasSuffix,omitempty"`
	PredicateEqualFold    *string  `json:"predicateEqualFold,omitempty"`
	PredicateContainsFold *string  `json:"predicateContainsFold,omitempty"`

	// "subjects" edge predicates.
	HasSubjects     *bool                `json:"hasSubjects,omitempty"`
	HasSubjectsWith []*SubjectWhereInput `json:"hasSubjectsWith,omitempty"`

	// "policy" edge predicates.
	HasPolicy     *bool                          `json:"hasPolicy,omitempty"`
	HasPolicyWith []*AttestationPolicyWhereInput `json:"hasPolicyWith,omitempty"`

	// "attestation_collections" edge predicates.
	HasAttestationCollections     *bool                              `json:"hasAttestationCollections,omitempty"`
	HasAttestationCollectionsWith []*AttestationCollectionWhereInput `json:"hasAttestationCollectionsWith,omitempty"`

	// "dsse" edge predicates.
	HasDsse     *bool             `json:"hasDsse,omitempty"`
	HasDsseWith []*DsseWhereInput `json:"hasDsseWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *StatementWhereInput) AddPredicates(predicates ...predicate.Statement) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the StatementWhereInput filter on the StatementQuery builder.
func (i *StatementWhereInput) Filter(q *StatementQuery) (*StatementQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyStatementWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyStatementWhereInput is returned in case the StatementWhereInput is empty.
var ErrEmptyStatementWhereInput = errors.New("ent: empty predicate StatementWhereInput")

// P returns a predicate for filtering statements.
// An error is returned if the input is empty or invalid.
func (i *StatementWhereInput) P() (predicate.Statement, error) {
	var predicates []predicate.Statement
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, statement.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Statement, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, statement.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Statement, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, statement.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, statement.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, statement.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, statement.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, statement.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, statement.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, statement.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, statement.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, statement.IDLTE(*i.IDLTE))
	}
	if i.Predicate != nil {
		predicates = append(predicates, statement.PredicateEQ(*i.Predicate))
	}
	if i.PredicateNEQ != nil {
		predicates = append(predicates, statement.PredicateNEQ(*i.PredicateNEQ))
	}
	if len(i.PredicateIn) > 0 {
		predicates = append(predicates, statement.PredicateIn(i.PredicateIn...))
	}
	if len(i.PredicateNotIn) > 0 {
		predicates = append(predicates, statement.PredicateNotIn(i.PredicateNotIn...))
	}
	if i.PredicateGT != nil {
		predicates = append(predicates, statement.PredicateGT(*i.PredicateGT))
	}
	if i.PredicateGTE != nil {
		predicates = append(predicates, statement.PredicateGTE(*i.PredicateGTE))
	}
	if i.PredicateLT != nil {
		predicates = append(predicates, statement.PredicateLT(*i.PredicateLT))
	}
	if i.PredicateLTE != nil {
		predicates = append(predicates, statement.PredicateLTE(*i.PredicateLTE))
	}
	if i.PredicateContains != nil {
		predicates = append(predicates, statement.PredicateContains(*i.PredicateContains))
	}
	if i.PredicateHasPrefix != nil {
		predicates = append(predicates, statement.PredicateHasPrefix(*i.PredicateHasPrefix))
	}
	if i.PredicateHasSuffix != nil {
		predicates = append(predicates, statement.PredicateHasSuffix(*i.PredicateHasSuffix))
	}
	if i.PredicateEqualFold != nil {
		predicates = append(predicates, statement.PredicateEqualFold(*i.PredicateEqualFold))
	}
	if i.PredicateContainsFold != nil {
		predicates = append(predicates, statement.PredicateContainsFold(*i.PredicateContainsFold))
	}

	if i.HasSubjects != nil {
		p := statement.HasSubjects()
		if !*i.HasSubjects {
			p = statement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubjectsWith) > 0 {
		with := make([]predicate.Subject, 0, len(i.HasSubjectsWith))
		for _, w := range i.HasSubjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, statement.HasSubjectsWith(with...))
	}
	if i.HasPolicy != nil {
		p := statement.HasPolicy()
		if !*i.HasPolicy {
			p = statement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPolicyWith) > 0 {
		with := make([]predicate.AttestationPolicy, 0, len(i.HasPolicyWith))
		for _, w := range i.HasPolicyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPolicyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, statement.HasPolicyWith(with...))
	}
	if i.HasAttestationCollections != nil {
		p := statement.HasAttestationCollections()
		if !*i.HasAttestationCollections {
			p = statement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAttestationCollectionsWith) > 0 {
		with := make([]predicate.AttestationCollection, 0, len(i.HasAttestationCollectionsWith))
		for _, w := range i.HasAttestationCollectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAttestationCollectionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, statement.HasAttestationCollectionsWith(with...))
	}
	if i.HasDsse != nil {
		p := statement.HasDsse()
		if !*i.HasDsse {
			p = statement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDsseWith) > 0 {
		with := make([]predicate.Dsse, 0, len(i.HasDsseWith))
		for _, w := range i.HasDsseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDsseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, statement.HasDsseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyStatementWhereInput
	case 1:
		return predicates[0], nil
	default:
		return statement.And(predicates...), nil
	}
}

// SubjectWhereInput represents a where input for filtering Subject queries.
type SubjectWhereInput struct {
	Predicates []predicate.Subject  `json:"-"`
	Not        *SubjectWhereInput   `json:"not,omitempty"`
	Or         []*SubjectWhereInput `json:"or,omitempty"`
	And        []*SubjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "subject_digests" edge predicates.
	HasSubjectDigests     *bool                      `json:"hasSubjectDigests,omitempty"`
	HasSubjectDigestsWith []*SubjectDigestWhereInput `json:"hasSubjectDigestsWith,omitempty"`

	// "statement" edge predicates.
	HasStatement     *bool                  `json:"hasStatement,omitempty"`
	HasStatementWith []*StatementWhereInput `json:"hasStatementWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SubjectWhereInput) AddPredicates(predicates ...predicate.Subject) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SubjectWhereInput filter on the SubjectQuery builder.
func (i *SubjectWhereInput) Filter(q *SubjectQuery) (*SubjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySubjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySubjectWhereInput is returned in case the SubjectWhereInput is empty.
var ErrEmptySubjectWhereInput = errors.New("ent: empty predicate SubjectWhereInput")

// P returns a predicate for filtering subjects.
// An error is returned if the input is empty or invalid.
func (i *SubjectWhereInput) P() (predicate.Subject, error) {
	var predicates []predicate.Subject
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, subject.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Subject, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, subject.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Subject, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, subject.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, subject.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, subject.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, subject.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, subject.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, subject.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, subject.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, subject.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, subject.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, subject.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, subject.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, subject.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, subject.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, subject.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, subject.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, subject.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, subject.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, subject.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, subject.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, subject.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, subject.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, subject.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasSubjectDigests != nil {
		p := subject.HasSubjectDigests()
		if !*i.HasSubjectDigests {
			p = subject.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubjectDigestsWith) > 0 {
		with := make([]predicate.SubjectDigest, 0, len(i.HasSubjectDigestsWith))
		for _, w := range i.HasSubjectDigestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubjectDigestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subject.HasSubjectDigestsWith(with...))
	}
	if i.HasStatement != nil {
		p := subject.HasStatement()
		if !*i.HasStatement {
			p = subject.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStatementWith) > 0 {
		with := make([]predicate.Statement, 0, len(i.HasStatementWith))
		for _, w := range i.HasStatementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStatementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subject.HasStatementWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySubjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return subject.And(predicates...), nil
	}
}

// SubjectDigestWhereInput represents a where input for filtering SubjectDigest queries.
type SubjectDigestWhereInput struct {
	Predicates []predicate.SubjectDigest  `json:"-"`
	Not        *SubjectDigestWhereInput   `json:"not,omitempty"`
	Or         []*SubjectDigestWhereInput `json:"or,omitempty"`
	And        []*SubjectDigestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "algorithm" field predicates.
	Algorithm             *string  `json:"algorithm,omitempty"`
	AlgorithmNEQ          *string  `json:"algorithmNEQ,omitempty"`
	AlgorithmIn           []string `json:"algorithmIn,omitempty"`
	AlgorithmNotIn        []string `json:"algorithmNotIn,omitempty"`
	AlgorithmGT           *string  `json:"algorithmGT,omitempty"`
	AlgorithmGTE          *string  `json:"algorithmGTE,omitempty"`
	AlgorithmLT           *string  `json:"algorithmLT,omitempty"`
	AlgorithmLTE          *string  `json:"algorithmLTE,omitempty"`
	AlgorithmContains     *string  `json:"algorithmContains,omitempty"`
	AlgorithmHasPrefix    *string  `json:"algorithmHasPrefix,omitempty"`
	AlgorithmHasSuffix    *string  `json:"algorithmHasSuffix,omitempty"`
	AlgorithmEqualFold    *string  `json:"algorithmEqualFold,omitempty"`
	AlgorithmContainsFold *string  `json:"algorithmContainsFold,omitempty"`

	// "value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`

	// "subject" edge predicates.
	HasSubject     *bool                `json:"hasSubject,omitempty"`
	HasSubjectWith []*SubjectWhereInput `json:"hasSubjectWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SubjectDigestWhereInput) AddPredicates(predicates ...predicate.SubjectDigest) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SubjectDigestWhereInput filter on the SubjectDigestQuery builder.
func (i *SubjectDigestWhereInput) Filter(q *SubjectDigestQuery) (*SubjectDigestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySubjectDigestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySubjectDigestWhereInput is returned in case the SubjectDigestWhereInput is empty.
var ErrEmptySubjectDigestWhereInput = errors.New("ent: empty predicate SubjectDigestWhereInput")

// P returns a predicate for filtering subjectdigests.
// An error is returned if the input is empty or invalid.
func (i *SubjectDigestWhereInput) P() (predicate.SubjectDigest, error) {
	var predicates []predicate.SubjectDigest
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, subjectdigest.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SubjectDigest, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, subjectdigest.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SubjectDigest, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, subjectdigest.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, subjectdigest.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, subjectdigest.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, subjectdigest.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, subjectdigest.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, subjectdigest.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, subjectdigest.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, subjectdigest.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, subjectdigest.IDLTE(*i.IDLTE))
	}
	if i.Algorithm != nil {
		predicates = append(predicates, subjectdigest.AlgorithmEQ(*i.Algorithm))
	}
	if i.AlgorithmNEQ != nil {
		predicates = append(predicates, subjectdigest.AlgorithmNEQ(*i.AlgorithmNEQ))
	}
	if len(i.AlgorithmIn) > 0 {
		predicates = append(predicates, subjectdigest.AlgorithmIn(i.AlgorithmIn...))
	}
	if len(i.AlgorithmNotIn) > 0 {
		predicates = append(predicates, subjectdigest.AlgorithmNotIn(i.AlgorithmNotIn...))
	}
	if i.AlgorithmGT != nil {
		predicates = append(predicates, subjectdigest.AlgorithmGT(*i.AlgorithmGT))
	}
	if i.AlgorithmGTE != nil {
		predicates = append(predicates, subjectdigest.AlgorithmGTE(*i.AlgorithmGTE))
	}
	if i.AlgorithmLT != nil {
		predicates = append(predicates, subjectdigest.AlgorithmLT(*i.AlgorithmLT))
	}
	if i.AlgorithmLTE != nil {
		predicates = append(predicates, subjectdigest.AlgorithmLTE(*i.AlgorithmLTE))
	}
	if i.AlgorithmContains != nil {
		predicates = append(predicates, subjectdigest.AlgorithmContains(*i.AlgorithmContains))
	}
	if i.AlgorithmHasPrefix != nil {
		predicates = append(predicates, subjectdigest.AlgorithmHasPrefix(*i.AlgorithmHasPrefix))
	}
	if i.AlgorithmHasSuffix != nil {
		predicates = append(predicates, subjectdigest.AlgorithmHasSuffix(*i.AlgorithmHasSuffix))
	}
	if i.AlgorithmEqualFold != nil {
		predicates = append(predicates, subjectdigest.AlgorithmEqualFold(*i.AlgorithmEqualFold))
	}
	if i.AlgorithmContainsFold != nil {
		predicates = append(predicates, subjectdigest.AlgorithmContainsFold(*i.AlgorithmContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, subjectdigest.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, subjectdigest.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, subjectdigest.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, subjectdigest.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, subjectdigest.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, subjectdigest.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, subjectdigest.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, subjectdigest.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, subjectdigest.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, subjectdigest.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, subjectdigest.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, subjectdigest.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, subjectdigest.ValueContainsFold(*i.ValueContainsFold))
	}

	if i.HasSubject != nil {
		p := subjectdigest.HasSubject()
		if !*i.HasSubject {
			p = subjectdigest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubjectWith) > 0 {
		with := make([]predicate.Subject, 0, len(i.HasSubjectWith))
		for _, w := range i.HasSubjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subjectdigest.HasSubjectWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySubjectDigestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return subjectdigest.And(predicates...), nil
	}
}

// TimestampWhereInput represents a where input for filtering Timestamp queries.
type TimestampWhereInput struct {
	Predicates []predicate.Timestamp  `json:"-"`
	Not        *TimestampWhereInput   `json:"not,omitempty"`
	Or         []*TimestampWhereInput `json:"or,omitempty"`
	And        []*TimestampWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "timestamp" field predicates.
	Timestamp      *time.Time  `json:"timestamp,omitempty"`
	TimestampNEQ   *time.Time  `json:"timestampNEQ,omitempty"`
	TimestampIn    []time.Time `json:"timestampIn,omitempty"`
	TimestampNotIn []time.Time `json:"timestampNotIn,omitempty"`
	TimestampGT    *time.Time  `json:"timestampGT,omitempty"`
	TimestampGTE   *time.Time  `json:"timestampGTE,omitempty"`
	TimestampLT    *time.Time  `json:"timestampLT,omitempty"`
	TimestampLTE   *time.Time  `json:"timestampLTE,omitempty"`

	// "signature" edge predicates.
	HasSignature     *bool                  `json:"hasSignature,omitempty"`
	HasSignatureWith []*SignatureWhereInput `json:"hasSignatureWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TimestampWhereInput) AddPredicates(predicates ...predicate.Timestamp) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TimestampWhereInput filter on the TimestampQuery builder.
func (i *TimestampWhereInput) Filter(q *TimestampQuery) (*TimestampQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTimestampWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTimestampWhereInput is returned in case the TimestampWhereInput is empty.
var ErrEmptyTimestampWhereInput = errors.New("ent: empty predicate TimestampWhereInput")

// P returns a predicate for filtering timestamps.
// An error is returned if the input is empty or invalid.
func (i *TimestampWhereInput) P() (predicate.Timestamp, error) {
	var predicates []predicate.Timestamp
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, timestamp.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Timestamp, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, timestamp.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Timestamp, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, timestamp.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, timestamp.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, timestamp.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, timestamp.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, timestamp.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, timestamp.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, timestamp.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, timestamp.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, timestamp.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, timestamp.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, timestamp.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, timestamp.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, timestamp.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, timestamp.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, timestamp.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, timestamp.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, timestamp.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, timestamp.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, timestamp.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, timestamp.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, timestamp.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, timestamp.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.Timestamp != nil {
		predicates = append(predicates, timestamp.TimestampEQ(*i.Timestamp))
	}
	if i.TimestampNEQ != nil {
		predicates = append(predicates, timestamp.TimestampNEQ(*i.TimestampNEQ))
	}
	if len(i.TimestampIn) > 0 {
		predicates = append(predicates, timestamp.TimestampIn(i.TimestampIn...))
	}
	if len(i.TimestampNotIn) > 0 {
		predicates = append(predicates, timestamp.TimestampNotIn(i.TimestampNotIn...))
	}
	if i.TimestampGT != nil {
		predicates = append(predicates, timestamp.TimestampGT(*i.TimestampGT))
	}
	if i.TimestampGTE != nil {
		predicates = append(predicates, timestamp.TimestampGTE(*i.TimestampGTE))
	}
	if i.TimestampLT != nil {
		predicates = append(predicates, timestamp.TimestampLT(*i.TimestampLT))
	}
	if i.TimestampLTE != nil {
		predicates = append(predicates, timestamp.TimestampLTE(*i.TimestampLTE))
	}

	if i.HasSignature != nil {
		p := timestamp.HasSignature()
		if !*i.HasSignature {
			p = timestamp.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSignatureWith) > 0 {
		with := make([]predicate.Signature, 0, len(i.HasSignatureWith))
		for _, w := range i.HasSignatureWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSignatureWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, timestamp.HasSignatureWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTimestampWhereInput
	case 1:
		return predicates[0], nil
	default:
		return timestamp.And(predicates...), nil
	}
}
