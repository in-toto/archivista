// Code generated by entc, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"github.com/testifysec/archivist/ent/attestation"
	"github.com/testifysec/archivist/ent/attestationcollection"
	"github.com/testifysec/archivist/ent/dsse"
	"github.com/testifysec/archivist/ent/payloaddigest"
	"github.com/testifysec/archivist/ent/predicate"
	"github.com/testifysec/archivist/ent/signature"
	"github.com/testifysec/archivist/ent/statement"
	"github.com/testifysec/archivist/ent/subject"
	"github.com/testifysec/archivist/ent/subjectdigest"
)

// AttestationWhereInput represents a where input for filtering Attestation queries.
type AttestationWhereInput struct {
	Predicates []predicate.Attestation  `json:"-"`
	Not        *AttestationWhereInput   `json:"not,omitempty"`
	Or         []*AttestationWhereInput `json:"or,omitempty"`
	And        []*AttestationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "attestation_collection" edge predicates.
	HasAttestationCollection     *bool                              `json:"hasAttestationCollection,omitempty"`
	HasAttestationCollectionWith []*AttestationCollectionWhereInput `json:"hasAttestationCollectionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AttestationWhereInput) AddPredicates(predicates ...predicate.Attestation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AttestationWhereInput filter on the AttestationQuery builder.
func (i *AttestationWhereInput) Filter(q *AttestationQuery) (*AttestationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAttestationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAttestationWhereInput is returned in case the AttestationWhereInput is empty.
var ErrEmptyAttestationWhereInput = errors.New("ent: empty predicate AttestationWhereInput")

// P returns a predicate for filtering attestations.
// An error is returned if the input is empty or invalid.
func (i *AttestationWhereInput) P() (predicate.Attestation, error) {
	var predicates []predicate.Attestation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, attestation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Attestation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, attestation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Attestation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, attestation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, attestation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, attestation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, attestation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, attestation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, attestation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, attestation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, attestation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, attestation.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, attestation.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, attestation.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, attestation.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, attestation.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, attestation.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, attestation.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, attestation.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, attestation.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, attestation.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, attestation.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, attestation.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, attestation.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, attestation.TypeContainsFold(*i.TypeContainsFold))
	}

	if i.HasAttestationCollection != nil {
		p := attestation.HasAttestationCollection()
		if !*i.HasAttestationCollection {
			p = attestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAttestationCollectionWith) > 0 {
		with := make([]predicate.AttestationCollection, 0, len(i.HasAttestationCollectionWith))
		for _, w := range i.HasAttestationCollectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAttestationCollectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, attestation.HasAttestationCollectionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAttestationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return attestation.And(predicates...), nil
	}
}

// AttestationCollectionWhereInput represents a where input for filtering AttestationCollection queries.
type AttestationCollectionWhereInput struct {
	Predicates []predicate.AttestationCollection  `json:"-"`
	Not        *AttestationCollectionWhereInput   `json:"not,omitempty"`
	Or         []*AttestationCollectionWhereInput `json:"or,omitempty"`
	And        []*AttestationCollectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "attestations" edge predicates.
	HasAttestations     *bool                    `json:"hasAttestations,omitempty"`
	HasAttestationsWith []*AttestationWhereInput `json:"hasAttestationsWith,omitempty"`

	// "statement" edge predicates.
	HasStatement     *bool                  `json:"hasStatement,omitempty"`
	HasStatementWith []*StatementWhereInput `json:"hasStatementWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AttestationCollectionWhereInput) AddPredicates(predicates ...predicate.AttestationCollection) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AttestationCollectionWhereInput filter on the AttestationCollectionQuery builder.
func (i *AttestationCollectionWhereInput) Filter(q *AttestationCollectionQuery) (*AttestationCollectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAttestationCollectionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAttestationCollectionWhereInput is returned in case the AttestationCollectionWhereInput is empty.
var ErrEmptyAttestationCollectionWhereInput = errors.New("ent: empty predicate AttestationCollectionWhereInput")

// P returns a predicate for filtering attestationcollections.
// An error is returned if the input is empty or invalid.
func (i *AttestationCollectionWhereInput) P() (predicate.AttestationCollection, error) {
	var predicates []predicate.AttestationCollection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, attestationcollection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AttestationCollection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, attestationcollection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AttestationCollection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, attestationcollection.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, attestationcollection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, attestationcollection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, attestationcollection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, attestationcollection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, attestationcollection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, attestationcollection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, attestationcollection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, attestationcollection.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, attestationcollection.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, attestationcollection.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, attestationcollection.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, attestationcollection.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, attestationcollection.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, attestationcollection.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, attestationcollection.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, attestationcollection.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, attestationcollection.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, attestationcollection.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, attestationcollection.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, attestationcollection.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, attestationcollection.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasAttestations != nil {
		p := attestationcollection.HasAttestations()
		if !*i.HasAttestations {
			p = attestationcollection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAttestationsWith) > 0 {
		with := make([]predicate.Attestation, 0, len(i.HasAttestationsWith))
		for _, w := range i.HasAttestationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAttestationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, attestationcollection.HasAttestationsWith(with...))
	}
	if i.HasStatement != nil {
		p := attestationcollection.HasStatement()
		if !*i.HasStatement {
			p = attestationcollection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStatementWith) > 0 {
		with := make([]predicate.Statement, 0, len(i.HasStatementWith))
		for _, w := range i.HasStatementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStatementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, attestationcollection.HasStatementWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAttestationCollectionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return attestationcollection.And(predicates...), nil
	}
}

// DsseWhereInput represents a where input for filtering Dsse queries.
type DsseWhereInput struct {
	Predicates []predicate.Dsse  `json:"-"`
	Not        *DsseWhereInput   `json:"not,omitempty"`
	Or         []*DsseWhereInput `json:"or,omitempty"`
	And        []*DsseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "gitbom_sha256" field predicates.
	GitbomSha256             *string  `json:"gitbomSha256,omitempty"`
	GitbomSha256NEQ          *string  `json:"gitbomSha256NEQ,omitempty"`
	GitbomSha256In           []string `json:"gitbomSha256In,omitempty"`
	GitbomSha256NotIn        []string `json:"gitbomSha256NotIn,omitempty"`
	GitbomSha256GT           *string  `json:"gitbomSha256GT,omitempty"`
	GitbomSha256GTE          *string  `json:"gitbomSha256GTE,omitempty"`
	GitbomSha256LT           *string  `json:"gitbomSha256LT,omitempty"`
	GitbomSha256LTE          *string  `json:"gitbomSha256LTE,omitempty"`
	GitbomSha256Contains     *string  `json:"gitbomSha256Contains,omitempty"`
	GitbomSha256HasPrefix    *string  `json:"gitbomSha256HasPrefix,omitempty"`
	GitbomSha256HasSuffix    *string  `json:"gitbomSha256HasSuffix,omitempty"`
	GitbomSha256EqualFold    *string  `json:"gitbomSha256EqualFold,omitempty"`
	GitbomSha256ContainsFold *string  `json:"gitbomSha256ContainsFold,omitempty"`

	// "payload_type" field predicates.
	PayloadType             *string  `json:"payloadType,omitempty"`
	PayloadTypeNEQ          *string  `json:"payloadTypeNEQ,omitempty"`
	PayloadTypeIn           []string `json:"payloadTypeIn,omitempty"`
	PayloadTypeNotIn        []string `json:"payloadTypeNotIn,omitempty"`
	PayloadTypeGT           *string  `json:"payloadTypeGT,omitempty"`
	PayloadTypeGTE          *string  `json:"payloadTypeGTE,omitempty"`
	PayloadTypeLT           *string  `json:"payloadTypeLT,omitempty"`
	PayloadTypeLTE          *string  `json:"payloadTypeLTE,omitempty"`
	PayloadTypeContains     *string  `json:"payloadTypeContains,omitempty"`
	PayloadTypeHasPrefix    *string  `json:"payloadTypeHasPrefix,omitempty"`
	PayloadTypeHasSuffix    *string  `json:"payloadTypeHasSuffix,omitempty"`
	PayloadTypeEqualFold    *string  `json:"payloadTypeEqualFold,omitempty"`
	PayloadTypeContainsFold *string  `json:"payloadTypeContainsFold,omitempty"`

	// "statement" edge predicates.
	HasStatement     *bool                  `json:"hasStatement,omitempty"`
	HasStatementWith []*StatementWhereInput `json:"hasStatementWith,omitempty"`

	// "signatures" edge predicates.
	HasSignatures     *bool                  `json:"hasSignatures,omitempty"`
	HasSignaturesWith []*SignatureWhereInput `json:"hasSignaturesWith,omitempty"`

	// "payload_digests" edge predicates.
	HasPayloadDigests     *bool                      `json:"hasPayloadDigests,omitempty"`
	HasPayloadDigestsWith []*PayloadDigestWhereInput `json:"hasPayloadDigestsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DsseWhereInput) AddPredicates(predicates ...predicate.Dsse) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DsseWhereInput filter on the DsseQuery builder.
func (i *DsseWhereInput) Filter(q *DsseQuery) (*DsseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDsseWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDsseWhereInput is returned in case the DsseWhereInput is empty.
var ErrEmptyDsseWhereInput = errors.New("ent: empty predicate DsseWhereInput")

// P returns a predicate for filtering dsses.
// An error is returned if the input is empty or invalid.
func (i *DsseWhereInput) P() (predicate.Dsse, error) {
	var predicates []predicate.Dsse
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dsse.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Dsse, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dsse.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Dsse, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dsse.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dsse.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dsse.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dsse.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dsse.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dsse.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dsse.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dsse.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dsse.IDLTE(*i.IDLTE))
	}
	if i.GitbomSha256 != nil {
		predicates = append(predicates, dsse.GitbomSha256EQ(*i.GitbomSha256))
	}
	if i.GitbomSha256NEQ != nil {
		predicates = append(predicates, dsse.GitbomSha256NEQ(*i.GitbomSha256NEQ))
	}
	if len(i.GitbomSha256In) > 0 {
		predicates = append(predicates, dsse.GitbomSha256In(i.GitbomSha256In...))
	}
	if len(i.GitbomSha256NotIn) > 0 {
		predicates = append(predicates, dsse.GitbomSha256NotIn(i.GitbomSha256NotIn...))
	}
	if i.GitbomSha256GT != nil {
		predicates = append(predicates, dsse.GitbomSha256GT(*i.GitbomSha256GT))
	}
	if i.GitbomSha256GTE != nil {
		predicates = append(predicates, dsse.GitbomSha256GTE(*i.GitbomSha256GTE))
	}
	if i.GitbomSha256LT != nil {
		predicates = append(predicates, dsse.GitbomSha256LT(*i.GitbomSha256LT))
	}
	if i.GitbomSha256LTE != nil {
		predicates = append(predicates, dsse.GitbomSha256LTE(*i.GitbomSha256LTE))
	}
	if i.GitbomSha256Contains != nil {
		predicates = append(predicates, dsse.GitbomSha256Contains(*i.GitbomSha256Contains))
	}
	if i.GitbomSha256HasPrefix != nil {
		predicates = append(predicates, dsse.GitbomSha256HasPrefix(*i.GitbomSha256HasPrefix))
	}
	if i.GitbomSha256HasSuffix != nil {
		predicates = append(predicates, dsse.GitbomSha256HasSuffix(*i.GitbomSha256HasSuffix))
	}
	if i.GitbomSha256EqualFold != nil {
		predicates = append(predicates, dsse.GitbomSha256EqualFold(*i.GitbomSha256EqualFold))
	}
	if i.GitbomSha256ContainsFold != nil {
		predicates = append(predicates, dsse.GitbomSha256ContainsFold(*i.GitbomSha256ContainsFold))
	}
	if i.PayloadType != nil {
		predicates = append(predicates, dsse.PayloadTypeEQ(*i.PayloadType))
	}
	if i.PayloadTypeNEQ != nil {
		predicates = append(predicates, dsse.PayloadTypeNEQ(*i.PayloadTypeNEQ))
	}
	if len(i.PayloadTypeIn) > 0 {
		predicates = append(predicates, dsse.PayloadTypeIn(i.PayloadTypeIn...))
	}
	if len(i.PayloadTypeNotIn) > 0 {
		predicates = append(predicates, dsse.PayloadTypeNotIn(i.PayloadTypeNotIn...))
	}
	if i.PayloadTypeGT != nil {
		predicates = append(predicates, dsse.PayloadTypeGT(*i.PayloadTypeGT))
	}
	if i.PayloadTypeGTE != nil {
		predicates = append(predicates, dsse.PayloadTypeGTE(*i.PayloadTypeGTE))
	}
	if i.PayloadTypeLT != nil {
		predicates = append(predicates, dsse.PayloadTypeLT(*i.PayloadTypeLT))
	}
	if i.PayloadTypeLTE != nil {
		predicates = append(predicates, dsse.PayloadTypeLTE(*i.PayloadTypeLTE))
	}
	if i.PayloadTypeContains != nil {
		predicates = append(predicates, dsse.PayloadTypeContains(*i.PayloadTypeContains))
	}
	if i.PayloadTypeHasPrefix != nil {
		predicates = append(predicates, dsse.PayloadTypeHasPrefix(*i.PayloadTypeHasPrefix))
	}
	if i.PayloadTypeHasSuffix != nil {
		predicates = append(predicates, dsse.PayloadTypeHasSuffix(*i.PayloadTypeHasSuffix))
	}
	if i.PayloadTypeEqualFold != nil {
		predicates = append(predicates, dsse.PayloadTypeEqualFold(*i.PayloadTypeEqualFold))
	}
	if i.PayloadTypeContainsFold != nil {
		predicates = append(predicates, dsse.PayloadTypeContainsFold(*i.PayloadTypeContainsFold))
	}

	if i.HasStatement != nil {
		p := dsse.HasStatement()
		if !*i.HasStatement {
			p = dsse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStatementWith) > 0 {
		with := make([]predicate.Statement, 0, len(i.HasStatementWith))
		for _, w := range i.HasStatementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStatementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dsse.HasStatementWith(with...))
	}
	if i.HasSignatures != nil {
		p := dsse.HasSignatures()
		if !*i.HasSignatures {
			p = dsse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSignaturesWith) > 0 {
		with := make([]predicate.Signature, 0, len(i.HasSignaturesWith))
		for _, w := range i.HasSignaturesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSignaturesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dsse.HasSignaturesWith(with...))
	}
	if i.HasPayloadDigests != nil {
		p := dsse.HasPayloadDigests()
		if !*i.HasPayloadDigests {
			p = dsse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPayloadDigestsWith) > 0 {
		with := make([]predicate.PayloadDigest, 0, len(i.HasPayloadDigestsWith))
		for _, w := range i.HasPayloadDigestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPayloadDigestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dsse.HasPayloadDigestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDsseWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dsse.And(predicates...), nil
	}
}

// PayloadDigestWhereInput represents a where input for filtering PayloadDigest queries.
type PayloadDigestWhereInput struct {
	Predicates []predicate.PayloadDigest  `json:"-"`
	Not        *PayloadDigestWhereInput   `json:"not,omitempty"`
	Or         []*PayloadDigestWhereInput `json:"or,omitempty"`
	And        []*PayloadDigestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "algorithm" field predicates.
	Algorithm             *string  `json:"algorithm,omitempty"`
	AlgorithmNEQ          *string  `json:"algorithmNEQ,omitempty"`
	AlgorithmIn           []string `json:"algorithmIn,omitempty"`
	AlgorithmNotIn        []string `json:"algorithmNotIn,omitempty"`
	AlgorithmGT           *string  `json:"algorithmGT,omitempty"`
	AlgorithmGTE          *string  `json:"algorithmGTE,omitempty"`
	AlgorithmLT           *string  `json:"algorithmLT,omitempty"`
	AlgorithmLTE          *string  `json:"algorithmLTE,omitempty"`
	AlgorithmContains     *string  `json:"algorithmContains,omitempty"`
	AlgorithmHasPrefix    *string  `json:"algorithmHasPrefix,omitempty"`
	AlgorithmHasSuffix    *string  `json:"algorithmHasSuffix,omitempty"`
	AlgorithmEqualFold    *string  `json:"algorithmEqualFold,omitempty"`
	AlgorithmContainsFold *string  `json:"algorithmContainsFold,omitempty"`

	// "value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`

	// "dsse" edge predicates.
	HasDsse     *bool             `json:"hasDsse,omitempty"`
	HasDsseWith []*DsseWhereInput `json:"hasDsseWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PayloadDigestWhereInput) AddPredicates(predicates ...predicate.PayloadDigest) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PayloadDigestWhereInput filter on the PayloadDigestQuery builder.
func (i *PayloadDigestWhereInput) Filter(q *PayloadDigestQuery) (*PayloadDigestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPayloadDigestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPayloadDigestWhereInput is returned in case the PayloadDigestWhereInput is empty.
var ErrEmptyPayloadDigestWhereInput = errors.New("ent: empty predicate PayloadDigestWhereInput")

// P returns a predicate for filtering payloaddigests.
// An error is returned if the input is empty or invalid.
func (i *PayloadDigestWhereInput) P() (predicate.PayloadDigest, error) {
	var predicates []predicate.PayloadDigest
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, payloaddigest.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PayloadDigest, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, payloaddigest.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PayloadDigest, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, payloaddigest.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, payloaddigest.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, payloaddigest.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, payloaddigest.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, payloaddigest.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, payloaddigest.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, payloaddigest.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, payloaddigest.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, payloaddigest.IDLTE(*i.IDLTE))
	}
	if i.Algorithm != nil {
		predicates = append(predicates, payloaddigest.AlgorithmEQ(*i.Algorithm))
	}
	if i.AlgorithmNEQ != nil {
		predicates = append(predicates, payloaddigest.AlgorithmNEQ(*i.AlgorithmNEQ))
	}
	if len(i.AlgorithmIn) > 0 {
		predicates = append(predicates, payloaddigest.AlgorithmIn(i.AlgorithmIn...))
	}
	if len(i.AlgorithmNotIn) > 0 {
		predicates = append(predicates, payloaddigest.AlgorithmNotIn(i.AlgorithmNotIn...))
	}
	if i.AlgorithmGT != nil {
		predicates = append(predicates, payloaddigest.AlgorithmGT(*i.AlgorithmGT))
	}
	if i.AlgorithmGTE != nil {
		predicates = append(predicates, payloaddigest.AlgorithmGTE(*i.AlgorithmGTE))
	}
	if i.AlgorithmLT != nil {
		predicates = append(predicates, payloaddigest.AlgorithmLT(*i.AlgorithmLT))
	}
	if i.AlgorithmLTE != nil {
		predicates = append(predicates, payloaddigest.AlgorithmLTE(*i.AlgorithmLTE))
	}
	if i.AlgorithmContains != nil {
		predicates = append(predicates, payloaddigest.AlgorithmContains(*i.AlgorithmContains))
	}
	if i.AlgorithmHasPrefix != nil {
		predicates = append(predicates, payloaddigest.AlgorithmHasPrefix(*i.AlgorithmHasPrefix))
	}
	if i.AlgorithmHasSuffix != nil {
		predicates = append(predicates, payloaddigest.AlgorithmHasSuffix(*i.AlgorithmHasSuffix))
	}
	if i.AlgorithmEqualFold != nil {
		predicates = append(predicates, payloaddigest.AlgorithmEqualFold(*i.AlgorithmEqualFold))
	}
	if i.AlgorithmContainsFold != nil {
		predicates = append(predicates, payloaddigest.AlgorithmContainsFold(*i.AlgorithmContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, payloaddigest.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, payloaddigest.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, payloaddigest.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, payloaddigest.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, payloaddigest.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, payloaddigest.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, payloaddigest.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, payloaddigest.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, payloaddigest.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, payloaddigest.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, payloaddigest.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, payloaddigest.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, payloaddigest.ValueContainsFold(*i.ValueContainsFold))
	}

	if i.HasDsse != nil {
		p := payloaddigest.HasDsse()
		if !*i.HasDsse {
			p = payloaddigest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDsseWith) > 0 {
		with := make([]predicate.Dsse, 0, len(i.HasDsseWith))
		for _, w := range i.HasDsseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDsseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, payloaddigest.HasDsseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPayloadDigestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return payloaddigest.And(predicates...), nil
	}
}

// SignatureWhereInput represents a where input for filtering Signature queries.
type SignatureWhereInput struct {
	Predicates []predicate.Signature  `json:"-"`
	Not        *SignatureWhereInput   `json:"not,omitempty"`
	Or         []*SignatureWhereInput `json:"or,omitempty"`
	And        []*SignatureWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "key_id" field predicates.
	KeyID             *string  `json:"keyID,omitempty"`
	KeyIDNEQ          *string  `json:"keyIDNEQ,omitempty"`
	KeyIDIn           []string `json:"keyIDIn,omitempty"`
	KeyIDNotIn        []string `json:"keyIDNotIn,omitempty"`
	KeyIDGT           *string  `json:"keyIDGT,omitempty"`
	KeyIDGTE          *string  `json:"keyIDGTE,omitempty"`
	KeyIDLT           *string  `json:"keyIDLT,omitempty"`
	KeyIDLTE          *string  `json:"keyIDLTE,omitempty"`
	KeyIDContains     *string  `json:"keyIDContains,omitempty"`
	KeyIDHasPrefix    *string  `json:"keyIDHasPrefix,omitempty"`
	KeyIDHasSuffix    *string  `json:"keyIDHasSuffix,omitempty"`
	KeyIDEqualFold    *string  `json:"keyIDEqualFold,omitempty"`
	KeyIDContainsFold *string  `json:"keyIDContainsFold,omitempty"`

	// "signature" field predicates.
	Signature             *string  `json:"signature,omitempty"`
	SignatureNEQ          *string  `json:"signatureNEQ,omitempty"`
	SignatureIn           []string `json:"signatureIn,omitempty"`
	SignatureNotIn        []string `json:"signatureNotIn,omitempty"`
	SignatureGT           *string  `json:"signatureGT,omitempty"`
	SignatureGTE          *string  `json:"signatureGTE,omitempty"`
	SignatureLT           *string  `json:"signatureLT,omitempty"`
	SignatureLTE          *string  `json:"signatureLTE,omitempty"`
	SignatureContains     *string  `json:"signatureContains,omitempty"`
	SignatureHasPrefix    *string  `json:"signatureHasPrefix,omitempty"`
	SignatureHasSuffix    *string  `json:"signatureHasSuffix,omitempty"`
	SignatureEqualFold    *string  `json:"signatureEqualFold,omitempty"`
	SignatureContainsFold *string  `json:"signatureContainsFold,omitempty"`

	// "dsse" edge predicates.
	HasDsse     *bool             `json:"hasDsse,omitempty"`
	HasDsseWith []*DsseWhereInput `json:"hasDsseWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SignatureWhereInput) AddPredicates(predicates ...predicate.Signature) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SignatureWhereInput filter on the SignatureQuery builder.
func (i *SignatureWhereInput) Filter(q *SignatureQuery) (*SignatureQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySignatureWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySignatureWhereInput is returned in case the SignatureWhereInput is empty.
var ErrEmptySignatureWhereInput = errors.New("ent: empty predicate SignatureWhereInput")

// P returns a predicate for filtering signatures.
// An error is returned if the input is empty or invalid.
func (i *SignatureWhereInput) P() (predicate.Signature, error) {
	var predicates []predicate.Signature
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, signature.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Signature, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, signature.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Signature, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, signature.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, signature.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, signature.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, signature.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, signature.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, signature.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, signature.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, signature.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, signature.IDLTE(*i.IDLTE))
	}
	if i.KeyID != nil {
		predicates = append(predicates, signature.KeyIDEQ(*i.KeyID))
	}
	if i.KeyIDNEQ != nil {
		predicates = append(predicates, signature.KeyIDNEQ(*i.KeyIDNEQ))
	}
	if len(i.KeyIDIn) > 0 {
		predicates = append(predicates, signature.KeyIDIn(i.KeyIDIn...))
	}
	if len(i.KeyIDNotIn) > 0 {
		predicates = append(predicates, signature.KeyIDNotIn(i.KeyIDNotIn...))
	}
	if i.KeyIDGT != nil {
		predicates = append(predicates, signature.KeyIDGT(*i.KeyIDGT))
	}
	if i.KeyIDGTE != nil {
		predicates = append(predicates, signature.KeyIDGTE(*i.KeyIDGTE))
	}
	if i.KeyIDLT != nil {
		predicates = append(predicates, signature.KeyIDLT(*i.KeyIDLT))
	}
	if i.KeyIDLTE != nil {
		predicates = append(predicates, signature.KeyIDLTE(*i.KeyIDLTE))
	}
	if i.KeyIDContains != nil {
		predicates = append(predicates, signature.KeyIDContains(*i.KeyIDContains))
	}
	if i.KeyIDHasPrefix != nil {
		predicates = append(predicates, signature.KeyIDHasPrefix(*i.KeyIDHasPrefix))
	}
	if i.KeyIDHasSuffix != nil {
		predicates = append(predicates, signature.KeyIDHasSuffix(*i.KeyIDHasSuffix))
	}
	if i.KeyIDEqualFold != nil {
		predicates = append(predicates, signature.KeyIDEqualFold(*i.KeyIDEqualFold))
	}
	if i.KeyIDContainsFold != nil {
		predicates = append(predicates, signature.KeyIDContainsFold(*i.KeyIDContainsFold))
	}
	if i.Signature != nil {
		predicates = append(predicates, signature.SignatureEQ(*i.Signature))
	}
	if i.SignatureNEQ != nil {
		predicates = append(predicates, signature.SignatureNEQ(*i.SignatureNEQ))
	}
	if len(i.SignatureIn) > 0 {
		predicates = append(predicates, signature.SignatureIn(i.SignatureIn...))
	}
	if len(i.SignatureNotIn) > 0 {
		predicates = append(predicates, signature.SignatureNotIn(i.SignatureNotIn...))
	}
	if i.SignatureGT != nil {
		predicates = append(predicates, signature.SignatureGT(*i.SignatureGT))
	}
	if i.SignatureGTE != nil {
		predicates = append(predicates, signature.SignatureGTE(*i.SignatureGTE))
	}
	if i.SignatureLT != nil {
		predicates = append(predicates, signature.SignatureLT(*i.SignatureLT))
	}
	if i.SignatureLTE != nil {
		predicates = append(predicates, signature.SignatureLTE(*i.SignatureLTE))
	}
	if i.SignatureContains != nil {
		predicates = append(predicates, signature.SignatureContains(*i.SignatureContains))
	}
	if i.SignatureHasPrefix != nil {
		predicates = append(predicates, signature.SignatureHasPrefix(*i.SignatureHasPrefix))
	}
	if i.SignatureHasSuffix != nil {
		predicates = append(predicates, signature.SignatureHasSuffix(*i.SignatureHasSuffix))
	}
	if i.SignatureEqualFold != nil {
		predicates = append(predicates, signature.SignatureEqualFold(*i.SignatureEqualFold))
	}
	if i.SignatureContainsFold != nil {
		predicates = append(predicates, signature.SignatureContainsFold(*i.SignatureContainsFold))
	}

	if i.HasDsse != nil {
		p := signature.HasDsse()
		if !*i.HasDsse {
			p = signature.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDsseWith) > 0 {
		with := make([]predicate.Dsse, 0, len(i.HasDsseWith))
		for _, w := range i.HasDsseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDsseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, signature.HasDsseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySignatureWhereInput
	case 1:
		return predicates[0], nil
	default:
		return signature.And(predicates...), nil
	}
}

// StatementWhereInput represents a where input for filtering Statement queries.
type StatementWhereInput struct {
	Predicates []predicate.Statement  `json:"-"`
	Not        *StatementWhereInput   `json:"not,omitempty"`
	Or         []*StatementWhereInput `json:"or,omitempty"`
	And        []*StatementWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "predicate" field predicates.
	Predicate             *string  `json:"predicate,omitempty"`
	PredicateNEQ          *string  `json:"predicateNEQ,omitempty"`
	PredicateIn           []string `json:"predicateIn,omitempty"`
	PredicateNotIn        []string `json:"predicateNotIn,omitempty"`
	PredicateGT           *string  `json:"predicateGT,omitempty"`
	PredicateGTE          *string  `json:"predicateGTE,omitempty"`
	PredicateLT           *string  `json:"predicateLT,omitempty"`
	PredicateLTE          *string  `json:"predicateLTE,omitempty"`
	PredicateContains     *string  `json:"predicateContains,omitempty"`
	PredicateHasPrefix    *string  `json:"predicateHasPrefix,omitempty"`
	PredicateHasSuffix    *string  `json:"predicateHasSuffix,omitempty"`
	PredicateEqualFold    *string  `json:"predicateEqualFold,omitempty"`
	PredicateContainsFold *string  `json:"predicateContainsFold,omitempty"`

	// "subjects" edge predicates.
	HasSubjects     *bool                `json:"hasSubjects,omitempty"`
	HasSubjectsWith []*SubjectWhereInput `json:"hasSubjectsWith,omitempty"`

	// "attestation_collections" edge predicates.
	HasAttestationCollections     *bool                              `json:"hasAttestationCollections,omitempty"`
	HasAttestationCollectionsWith []*AttestationCollectionWhereInput `json:"hasAttestationCollectionsWith,omitempty"`

	// "dsse" edge predicates.
	HasDsse     *bool             `json:"hasDsse,omitempty"`
	HasDsseWith []*DsseWhereInput `json:"hasDsseWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *StatementWhereInput) AddPredicates(predicates ...predicate.Statement) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the StatementWhereInput filter on the StatementQuery builder.
func (i *StatementWhereInput) Filter(q *StatementQuery) (*StatementQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyStatementWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyStatementWhereInput is returned in case the StatementWhereInput is empty.
var ErrEmptyStatementWhereInput = errors.New("ent: empty predicate StatementWhereInput")

// P returns a predicate for filtering statements.
// An error is returned if the input is empty or invalid.
func (i *StatementWhereInput) P() (predicate.Statement, error) {
	var predicates []predicate.Statement
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, statement.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Statement, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, statement.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Statement, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, statement.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, statement.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, statement.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, statement.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, statement.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, statement.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, statement.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, statement.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, statement.IDLTE(*i.IDLTE))
	}
	if i.Predicate != nil {
		predicates = append(predicates, statement.PredicateEQ(*i.Predicate))
	}
	if i.PredicateNEQ != nil {
		predicates = append(predicates, statement.PredicateNEQ(*i.PredicateNEQ))
	}
	if len(i.PredicateIn) > 0 {
		predicates = append(predicates, statement.PredicateIn(i.PredicateIn...))
	}
	if len(i.PredicateNotIn) > 0 {
		predicates = append(predicates, statement.PredicateNotIn(i.PredicateNotIn...))
	}
	if i.PredicateGT != nil {
		predicates = append(predicates, statement.PredicateGT(*i.PredicateGT))
	}
	if i.PredicateGTE != nil {
		predicates = append(predicates, statement.PredicateGTE(*i.PredicateGTE))
	}
	if i.PredicateLT != nil {
		predicates = append(predicates, statement.PredicateLT(*i.PredicateLT))
	}
	if i.PredicateLTE != nil {
		predicates = append(predicates, statement.PredicateLTE(*i.PredicateLTE))
	}
	if i.PredicateContains != nil {
		predicates = append(predicates, statement.PredicateContains(*i.PredicateContains))
	}
	if i.PredicateHasPrefix != nil {
		predicates = append(predicates, statement.PredicateHasPrefix(*i.PredicateHasPrefix))
	}
	if i.PredicateHasSuffix != nil {
		predicates = append(predicates, statement.PredicateHasSuffix(*i.PredicateHasSuffix))
	}
	if i.PredicateEqualFold != nil {
		predicates = append(predicates, statement.PredicateEqualFold(*i.PredicateEqualFold))
	}
	if i.PredicateContainsFold != nil {
		predicates = append(predicates, statement.PredicateContainsFold(*i.PredicateContainsFold))
	}

	if i.HasSubjects != nil {
		p := statement.HasSubjects()
		if !*i.HasSubjects {
			p = statement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubjectsWith) > 0 {
		with := make([]predicate.Subject, 0, len(i.HasSubjectsWith))
		for _, w := range i.HasSubjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubjectsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, statement.HasSubjectsWith(with...))
	}
	if i.HasAttestationCollections != nil {
		p := statement.HasAttestationCollections()
		if !*i.HasAttestationCollections {
			p = statement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAttestationCollectionsWith) > 0 {
		with := make([]predicate.AttestationCollection, 0, len(i.HasAttestationCollectionsWith))
		for _, w := range i.HasAttestationCollectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAttestationCollectionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, statement.HasAttestationCollectionsWith(with...))
	}
	if i.HasDsse != nil {
		p := statement.HasDsse()
		if !*i.HasDsse {
			p = statement.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDsseWith) > 0 {
		with := make([]predicate.Dsse, 0, len(i.HasDsseWith))
		for _, w := range i.HasDsseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDsseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, statement.HasDsseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyStatementWhereInput
	case 1:
		return predicates[0], nil
	default:
		return statement.And(predicates...), nil
	}
}

// SubjectWhereInput represents a where input for filtering Subject queries.
type SubjectWhereInput struct {
	Predicates []predicate.Subject  `json:"-"`
	Not        *SubjectWhereInput   `json:"not,omitempty"`
	Or         []*SubjectWhereInput `json:"or,omitempty"`
	And        []*SubjectWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "subject_digests" edge predicates.
	HasSubjectDigests     *bool                      `json:"hasSubjectDigests,omitempty"`
	HasSubjectDigestsWith []*SubjectDigestWhereInput `json:"hasSubjectDigestsWith,omitempty"`

	// "statement" edge predicates.
	HasStatement     *bool                  `json:"hasStatement,omitempty"`
	HasStatementWith []*StatementWhereInput `json:"hasStatementWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SubjectWhereInput) AddPredicates(predicates ...predicate.Subject) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SubjectWhereInput filter on the SubjectQuery builder.
func (i *SubjectWhereInput) Filter(q *SubjectQuery) (*SubjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySubjectWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySubjectWhereInput is returned in case the SubjectWhereInput is empty.
var ErrEmptySubjectWhereInput = errors.New("ent: empty predicate SubjectWhereInput")

// P returns a predicate for filtering subjects.
// An error is returned if the input is empty or invalid.
func (i *SubjectWhereInput) P() (predicate.Subject, error) {
	var predicates []predicate.Subject
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, subject.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Subject, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, subject.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Subject, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, subject.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, subject.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, subject.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, subject.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, subject.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, subject.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, subject.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, subject.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, subject.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, subject.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, subject.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, subject.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, subject.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, subject.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, subject.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, subject.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, subject.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, subject.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, subject.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, subject.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, subject.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, subject.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasSubjectDigests != nil {
		p := subject.HasSubjectDigests()
		if !*i.HasSubjectDigests {
			p = subject.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubjectDigestsWith) > 0 {
		with := make([]predicate.SubjectDigest, 0, len(i.HasSubjectDigestsWith))
		for _, w := range i.HasSubjectDigestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubjectDigestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subject.HasSubjectDigestsWith(with...))
	}
	if i.HasStatement != nil {
		p := subject.HasStatement()
		if !*i.HasStatement {
			p = subject.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStatementWith) > 0 {
		with := make([]predicate.Statement, 0, len(i.HasStatementWith))
		for _, w := range i.HasStatementWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStatementWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subject.HasStatementWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySubjectWhereInput
	case 1:
		return predicates[0], nil
	default:
		return subject.And(predicates...), nil
	}
}

// SubjectDigestWhereInput represents a where input for filtering SubjectDigest queries.
type SubjectDigestWhereInput struct {
	Predicates []predicate.SubjectDigest  `json:"-"`
	Not        *SubjectDigestWhereInput   `json:"not,omitempty"`
	Or         []*SubjectDigestWhereInput `json:"or,omitempty"`
	And        []*SubjectDigestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "algorithm" field predicates.
	Algorithm             *string  `json:"algorithm,omitempty"`
	AlgorithmNEQ          *string  `json:"algorithmNEQ,omitempty"`
	AlgorithmIn           []string `json:"algorithmIn,omitempty"`
	AlgorithmNotIn        []string `json:"algorithmNotIn,omitempty"`
	AlgorithmGT           *string  `json:"algorithmGT,omitempty"`
	AlgorithmGTE          *string  `json:"algorithmGTE,omitempty"`
	AlgorithmLT           *string  `json:"algorithmLT,omitempty"`
	AlgorithmLTE          *string  `json:"algorithmLTE,omitempty"`
	AlgorithmContains     *string  `json:"algorithmContains,omitempty"`
	AlgorithmHasPrefix    *string  `json:"algorithmHasPrefix,omitempty"`
	AlgorithmHasSuffix    *string  `json:"algorithmHasSuffix,omitempty"`
	AlgorithmEqualFold    *string  `json:"algorithmEqualFold,omitempty"`
	AlgorithmContainsFold *string  `json:"algorithmContainsFold,omitempty"`

	// "value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`

	// "subject" edge predicates.
	HasSubject     *bool                `json:"hasSubject,omitempty"`
	HasSubjectWith []*SubjectWhereInput `json:"hasSubjectWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SubjectDigestWhereInput) AddPredicates(predicates ...predicate.SubjectDigest) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SubjectDigestWhereInput filter on the SubjectDigestQuery builder.
func (i *SubjectDigestWhereInput) Filter(q *SubjectDigestQuery) (*SubjectDigestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySubjectDigestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySubjectDigestWhereInput is returned in case the SubjectDigestWhereInput is empty.
var ErrEmptySubjectDigestWhereInput = errors.New("ent: empty predicate SubjectDigestWhereInput")

// P returns a predicate for filtering subjectdigests.
// An error is returned if the input is empty or invalid.
func (i *SubjectDigestWhereInput) P() (predicate.SubjectDigest, error) {
	var predicates []predicate.SubjectDigest
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, subjectdigest.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SubjectDigest, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, subjectdigest.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SubjectDigest, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, subjectdigest.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, subjectdigest.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, subjectdigest.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, subjectdigest.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, subjectdigest.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, subjectdigest.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, subjectdigest.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, subjectdigest.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, subjectdigest.IDLTE(*i.IDLTE))
	}
	if i.Algorithm != nil {
		predicates = append(predicates, subjectdigest.AlgorithmEQ(*i.Algorithm))
	}
	if i.AlgorithmNEQ != nil {
		predicates = append(predicates, subjectdigest.AlgorithmNEQ(*i.AlgorithmNEQ))
	}
	if len(i.AlgorithmIn) > 0 {
		predicates = append(predicates, subjectdigest.AlgorithmIn(i.AlgorithmIn...))
	}
	if len(i.AlgorithmNotIn) > 0 {
		predicates = append(predicates, subjectdigest.AlgorithmNotIn(i.AlgorithmNotIn...))
	}
	if i.AlgorithmGT != nil {
		predicates = append(predicates, subjectdigest.AlgorithmGT(*i.AlgorithmGT))
	}
	if i.AlgorithmGTE != nil {
		predicates = append(predicates, subjectdigest.AlgorithmGTE(*i.AlgorithmGTE))
	}
	if i.AlgorithmLT != nil {
		predicates = append(predicates, subjectdigest.AlgorithmLT(*i.AlgorithmLT))
	}
	if i.AlgorithmLTE != nil {
		predicates = append(predicates, subjectdigest.AlgorithmLTE(*i.AlgorithmLTE))
	}
	if i.AlgorithmContains != nil {
		predicates = append(predicates, subjectdigest.AlgorithmContains(*i.AlgorithmContains))
	}
	if i.AlgorithmHasPrefix != nil {
		predicates = append(predicates, subjectdigest.AlgorithmHasPrefix(*i.AlgorithmHasPrefix))
	}
	if i.AlgorithmHasSuffix != nil {
		predicates = append(predicates, subjectdigest.AlgorithmHasSuffix(*i.AlgorithmHasSuffix))
	}
	if i.AlgorithmEqualFold != nil {
		predicates = append(predicates, subjectdigest.AlgorithmEqualFold(*i.AlgorithmEqualFold))
	}
	if i.AlgorithmContainsFold != nil {
		predicates = append(predicates, subjectdigest.AlgorithmContainsFold(*i.AlgorithmContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, subjectdigest.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, subjectdigest.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, subjectdigest.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, subjectdigest.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, subjectdigest.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, subjectdigest.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, subjectdigest.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, subjectdigest.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, subjectdigest.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, subjectdigest.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, subjectdigest.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, subjectdigest.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, subjectdigest.ValueContainsFold(*i.ValueContainsFold))
	}

	if i.HasSubject != nil {
		p := subjectdigest.HasSubject()
		if !*i.HasSubject {
			p = subjectdigest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubjectWith) > 0 {
		with := make([]predicate.Subject, 0, len(i.HasSubjectWith))
		for _, w := range i.HasSubjectWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubjectWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subjectdigest.HasSubjectWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySubjectDigestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return subjectdigest.And(predicates...), nil
	}
}
